<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard de Estoque com An√°lise Preditiva - Borracha</title>
    <link rel="stylesheet" href="styles.css">

</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìä Dashboard de Estoque - Borracha</h1>
            <div class="company-logo">
                <img src="https://usiquimica.com.br/wp-content/uploads/2022/05/usiquimica-logo-horizontal-1.png" alt="USIQUIMICA" />
            </div>
        </div>
        
        <div class="import-section">
            <div class="import-header" onclick="toggleImportSection()">
                <h3>üìä Importar Dados da Planilha</h3>
                <span class="toggle-icon" id="toggleIcon">‚ñº</span>
            </div>
            <div class="import-content" id="importContent">
                <div class="offline-notice">
                    <strong>üåê Modo Offline</strong> - Este dashboard funciona sem servidor! 
                    Importe suas planilhas e compartilhe os arquivos atualizados com sua equipe.
                    <div class="browser-mode-indicator" id="browserModeIndicator">
                        üîç Detectando modo do navegador...
                    </div>
                </div>
                
                <div class="file-input">
                    <input type="file" id="excelFile" accept=".xlsx,.xls,.csv" />
                    <button onclick="importData()">Importar Planilha</button>
                    <button onclick="tryAutoSave()" id="autoSaveBtn" class="btn-auto-save" style="display: none;">Configurar Pasta</button>
                    <button onclick="reconfigureAutoSave()" id="reconfigBtn" style="display: none; background-color: #6c757d;">üîß Reconfigurar</button>
                    <button onclick="openTemplateGenerator()" style="background-color: #28a745;">üìã Template</button>
                </div>
                <div id="importMessages"></div>
                <div id="mappingDebug" class="mapping-debug" style="display: none;"></div>
                <div id="lastUpdateInfo" style="font-size: 12px; color: #666; margin: 10px 0;"></div>
                <div id="debugInfo" class="debug-info" style="display: none;"></div>
                <small><strong>v1.3 - Importador Inteligente:</strong> Agora identifica automaticamente NOVEMBRO, DEZEMBRO e COBERTURA, al√©m de permitir escolher qual aba importar em planilhas com m√∫ltiplos meses.</small>
                
                <div class="download-section">
                    <h4>üìã Compartilhar Dados</h4>
                    <p>Ap√≥s importar, baixe o arquivo de dados atualizado e compartilhe com sua equipe:</p>
                    <button onclick="downloadDataFile()" style="background-color: #28a745; font-size: 16px; padding: 10px 20px;">üíæ Baixar data.js Atualizado</button>
                    <button onclick="testAutoSave()" id="testBtn" style="display: none; background-color: #17a2b8; margin-left: 10px;">üß™ Testar</button>
                    <button onclick="runDiagnostic()" style="background-color: #6c757d; margin-left: 10px;">üîç Diagn√≥stico</button>
                    <button onclick="toggleDebug()" style="background-color: #ffc107; margin-left: 10px;">üêõ Debug</button>
                    <button onclick="toggleMappingDebug()" style="background-color: #17a2b8; margin-left: 10px;">üìã Mapeamento</button>
                    <br><br>
                    <div style="background: #e8f4fd; padding: 12px; border-radius: 6px; border-left: 4px solid #0066cc;">
                        <strong>üîç Como compartilhar seus dados:</strong><br>
                        1. Clique em "üíæ Baixar data.js Atualizado" ap√≥s importar<br>
                        2. Substitua o arquivo <code>data.js</code> na pasta compartilhada<br>
                        3. Todos que acessarem o dashboard ver√£o os dados atualizados
                    </div>
                </div>
            </div>
        </div>

        <div class="search-section">
            <div class="search-container">
                <input
                    type="text"
                    id="globalSearch"
                    class="search-input"
                    placeholder="üîç Busque por c√≥digo, nome ou descreva o que procura..."
                />
            </div>
            <div class="search-results" id="searchResults"></div>
            <div class="search-selection" id="searchSelection" aria-live="polite"></div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>Fam√≠lia:</label>
                <select id="familyFilter" onchange="filterByFamily()">
                    <option value="">Todas as Fam√≠lias</option>
                </select>
            </div>

            <div class="control-group">
                <label>Fornecedor:</label>
                <select id="supplierFilter" onchange="filterBySupplier()">
                    <option value="">Todos os Fornecedores</option>
                </select>
            </div>

            <div class="control-group">
                <label>Estabelecimento:</label>
                <select id="establishmentFilter" onchange="filterByEstablishment()">
                    <option value="">Todos os Estabelecimentos</option>
                    <option value="1-4">1-4 (GUARULHOS)</option>
                    <option value="90-13">90-13 (ITAJA√ç)</option>
                    <option value="90-15">90-15 (GARUVA)</option>
                </select>
            </div>

            <div class="control-group control-actions">
                <button onclick="showExportModal()">üì§ Exportar</button>
                <button onclick="updateData()">üîÑ Atualizar</button>
            </div>
        </div>

        <div class="summary-card">
            <h3 class="header-label">Resumo Geral <span class="info-icon has-tooltip" tabindex="0" aria-label="Resumo Geral" data-tooltip="Indicadores principais do estoque considerando os filtros atuais, ajudando a entender a distribui√ß√£o e risco de ruptura." data-tooltip-position="top">?</span></h3>
            <div class="summary-stats">
                <div class="stat-item">
                    <div class="stat-value" id="totalProducts">0</div>
                    <div class="stat-label"><span class="label-text">Total de Produtos</span><span class="info-icon has-tooltip" tabindex="0" aria-label="Total de produtos" data-tooltip="Quantidade total de SKUs √∫nicos vis√≠veis ap√≥s aplicar filtros de busca e estabelecimento." data-tooltip-position="top">?</span></div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="avgStockMonths">0.0</div>
                    <div class="stat-label"><span class="label-text">M√©dia de Estoque (meses)</span><span class="info-icon has-tooltip" tabindex="0" aria-label="M√©dia de estoque" data-tooltip="Tempo m√©dio de cobertura em meses considerando todo o estoque dispon√≠vel dividido pelo consumo m√©dio dos √∫ltimos meses." data-tooltip-position="top">?</span></div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="totalCoverage">--</div>
                    <div class="stat-label"><span class="label-text">Cobertura Total</span><span class="info-icon has-tooltip" tabindex="0" aria-label="Cobertura total" data-tooltip="Soma da cobertura (em meses) informada na planilha para os itens filtrados." data-tooltip-position="top">?</span></div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="totalStockValue">0</div>
                    <div class="stat-label"><span class="label-text">Estoque Total</span><span class="info-icon has-tooltip" tabindex="0" aria-label="Estoque total" data-tooltip="Soma das unidades dispon√≠veis considerando todos os filtros e estabelecimentos selecionados." data-tooltip-position="top">?</span></div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="totalFamilies">0</div>
                    <div class="stat-label"><span class="label-text">Fam√≠lias de Produtos</span><span class="info-icon has-tooltip" tabindex="0" aria-label="Fam√≠lias de produtos" data-tooltip="N√∫mero de fam√≠lias distintas representadas na lista atual de produtos." data-tooltip-position="top">?</span></div>
                </div>
            </div>
        </div>

        <div class="predictive-section" id="predictiveAnalysis">
            <div class="predictive-header">
                <div>
                    <h3 class="header-label">üîÆ An√°lise Preditiva <span class="info-icon has-tooltip" tabindex="0" aria-label="An√°lise preditiva" data-tooltip="Resumo visual dos riscos de ruptura com base na cobertura em dias e meses de cada item." data-tooltip-position="top">?</span></h3>
                    <p class="predictive-subtitle">Configure os limites de alerta e aplique filtros inteligentes em um √∫nico painel para monitorar riscos de ruptura com linguagem objetiva.</p>
                </div>
            </div>

            <div class="prediction-actions">
                <div class="prediction-chip-groups">
                    <div class="prediction-chip-group" data-chip-group="coverage">
                        <span class="chip-group-title">Cobertura</span>
                        <div class="prediction-chip-collection" id="coverageQuickFilters">
                            <button class="prediction-item clickable" type="button" data-coverage-filter="critical" onclick="filterCriticalStock()" aria-pressed="false">
                                <span class="filter-content">
                                    <span class="filter-title">Estoque cr√≠tico</span>
                                    <span class="filter-helper">Cobertura &lt; <span data-coverage-threshold="critical">2 meses</span></span>
                                </span>
                                <span class="filter-count" id="coverageCriticalCount">0 itens</span>
                            </button>
                            <button class="prediction-item clickable" type="button" data-coverage-filter="low" onclick="filterLowStock()" aria-pressed="false">
                                <span class="filter-content">
                                    <span class="filter-title">Estoque baixo</span>
                                    <span class="filter-helper">Entre <span data-coverage-range="low-start">2 meses</span> e <span data-coverage-range="low-end">6 meses</span></span>
                                </span>
                                <span class="filter-count" id="coverageLowCount">0 itens</span>
                            </button>
                            <button class="prediction-item clickable" type="button" data-coverage-filter="high" onclick="filterHighStock()" aria-pressed="false">
                                <span class="filter-content">
                                    <span class="filter-title">Slow moving</span>
                                    <span class="filter-helper">Acima de <span data-coverage-threshold="slow">6 meses</span></span>
                                </span>
                                <span class="filter-count" id="coverageSlowCount">0 itens</span>
                            </button>
                        </div>
                    </div>
                    <div class="prediction-chip-group" data-chip-group="advanced">
                        <span class="chip-group-title">Filtros avan√ßados</span>
                        <div class="prediction-chip-collection" id="advancedFilterChips">
                            <button class="prediction-item clickable" type="button" data-advanced-filter="no-stock" onclick="filterByAdvancedStock('no-stock')" aria-pressed="false">
                                <span class="filter-content">
                                    <span class="filter-title">Sem estoque</span>
                                    <span class="filter-helper">Produtos com ruptura imediata</span>
                                </span>
                                <span class="filter-count" data-advanced-count="no-stock">0 itens</span>
                            </button>
                            <button class="prediction-item clickable" type="button" data-advanced-filter="over50" onclick="filterByAdvancedStock('over50')" aria-pressed="false">
                                <span class="filter-content">
                                    <span class="filter-title">Estoque &gt; 50 meses</span>
                                    <span class="filter-helper">Cobertura extremamente alta</span>
                                </span>
                                <span class="filter-count" data-advanced-count="over50">0 itens</span>
                            </button>
                            <button class="prediction-item clickable" type="button" data-advanced-filter="abc-a" onclick="filterByAdvancedStock('abc-a')" aria-pressed="false">
                                <span class="filter-content">
                                    <span class="filter-title">Classe A</span>
                                    <span class="filter-helper secondary">Top 5% por venda</span>
                                </span>
                                <span class="filter-count" data-advanced-count="abc-a">0 itens</span>
                            </button>
                            <button class="prediction-item clickable" type="button" data-advanced-filter="abc-b" onclick="filterByAdvancedStock('abc-b')" aria-pressed="false">
                                <span class="filter-content">
                                    <span class="filter-title">Classe B</span>
                                    <span class="filter-helper secondary">Itens intermedi√°rios</span>
                                </span>
                                <span class="filter-count" data-advanced-count="abc-b">0 itens</span>
                            </button>
                            <button class="prediction-item clickable" type="button" data-advanced-filter="abc-c" onclick="filterByAdvancedStock('abc-c')" aria-pressed="false">
                                <span class="filter-content">
                                    <span class="filter-title">Classe C</span>
                                    <span class="filter-helper secondary">Cauda longa</span>
                                </span>
                                <span class="filter-count" data-advanced-count="abc-c">0 itens</span>
                            </button>
                            <button class="prediction-item clickable" type="button" data-advanced-filter="top-sellers-risk" onclick="filterByAdvancedStock('top-sellers-risk')" aria-pressed="false">
                                <span class="filter-content">
                                    <span class="filter-title">Top sellers em risco</span>
                                    <span class="filter-helper">Grandes receitas com &le; 2M</span>
                                </span>
                                <span class="filter-count" data-advanced-count="top-sellers-risk">0 itens</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="prediction-chart-grid" role="group" aria-label="Resumo preditivo por risco">
                <div class="prediction-chart-card" data-prediction-filter="zero30">
                    <div class="prediction-chart-header">
                        <span class="prediction-chart-title">Ruptura urgente <span class="info-icon has-tooltip" tabindex="0" aria-label="Cobertura urgente" data-tooltip="Resumo dos itens sem estoque ou com ruptura prevista dentro do limite urgente configurado." data-tooltip-position="top">?</span></span>
                    </div>
                    <div class="prediction-chart-body">
                        <div class="prediction-chart-visual">
                            <canvas id="urgentRiskChart" role="img" aria-label="Distribui√ß√£o por fam√≠lia dos itens cr√≠ticos" width="160" height="160"></canvas>
                            <div class="prediction-chart-center">
                                <span class="prediction-chart-total" id="urgentRiskValue">--</span>
                                <span class="prediction-chart-percent" id="urgentRiskPercent">--%</span>
                                <span class="prediction-chart-total-label">itens</span>
                            </div>
                        </div>
                        <div class="prediction-chart-legend" id="urgentRiskLegend"></div>
                    </div>
                    <div class="prediction-chart-empty" id="urgentRiskEmpty" hidden>Sem itens com previs√£o para exibir.</div>
                    <span class="prediction-chart-helper" id="urgentRiskHelper">Itens que zeram em at√© <span data-urgent-days>--</span> dias. <span class="prediction-chart-detail" id="urgentRiskDetail"></span></span>
                </div>

                <div class="prediction-chart-card" data-prediction-filter="zero60">
                    <div class="prediction-chart-header">
                        <span class="prediction-chart-title">Em aten√ß√£o <span class="info-icon has-tooltip" tabindex="0" aria-label="Cobertura em aten√ß√£o" data-tooltip="Resumo dos itens que entram em ruptura logo ap√≥s o limite urgente configurado." data-tooltip-position="top">?</span></span>
                    </div>
                    <div class="prediction-chart-body">
                        <div class="prediction-chart-visual">
                            <canvas id="warningRiskChart" role="img" aria-label="Distribui√ß√£o por fam√≠lia dos itens em aten√ß√£o" width="160" height="160"></canvas>
                            <div class="prediction-chart-center">
                                <span class="prediction-chart-total" id="warningRiskValue">--</span>
                                <span class="prediction-chart-percent" id="warningRiskPercent">--%</span>
                                <span class="prediction-chart-total-label">itens</span>
                            </div>
                        </div>
                        <div class="prediction-chart-legend" id="warningRiskLegend"></div>
                    </div>
                    <div class="prediction-chart-empty" id="warningRiskEmpty" hidden>Sem itens com previs√£o para exibir.</div>
                    <span class="prediction-chart-helper" id="warningRiskHelper">Cobertura entre <span data-warning-start>--</span> e <span data-warning-days>--</span> dias. <span class="prediction-chart-detail" id="warningRiskDetail"></span></span>
                </div>

                <div class="prediction-chart-card" data-prediction-filter="comfortable" id="comfortableRiskCard">
                    <div class="prediction-chart-header">
                        <span class="prediction-chart-title">Cobertura confort√°vel <span class="info-icon has-tooltip" tabindex="0" aria-label="Cobertura confort√°vel" data-tooltip="Resumo dos itens com cobertura confort√°vel acima do limite configurado." data-tooltip-position="top">?</span></span>
                    </div>
                    <div class="prediction-chart-body">
                        <div class="prediction-chart-visual">
                            <canvas id="comfortableRiskChart" role="img" aria-label="Distribui√ß√£o por fam√≠lia dos itens com cobertura confort√°vel" width="160" height="160"></canvas>
                            <div class="prediction-chart-center">
                                <span class="prediction-chart-total" id="comfortableRiskValue">--</span>
                                <span class="prediction-chart-percent" id="comfortableRiskPercent">--%</span>
                                <span class="prediction-chart-total-label">itens</span>
                            </div>
                        </div>
                        <div class="prediction-chart-legend" id="comfortableRiskLegend"></div>
                    </div>
                    <div class="prediction-chart-empty" id="comfortableRiskEmpty" hidden>Sem itens com previs√£o para exibir.</div>
                    <span class="prediction-chart-helper" id="comfortableRiskHelper">Cobertura superior a <span data-warning-days>--</span> dias. <span class="prediction-chart-detail" id="comfortableRiskDetail"></span></span>
                </div>
            </div>

        </div>

        <div class="pareto-section">
            <h3 class="header-label">üìä An√°lise ABC por Vendas <span class="info-icon has-tooltip" tabindex="0" aria-label="An√°lise ABC por Vendas" data-tooltip="Organizamos os produtos conforme a fatia que cada um representa das vendas dos √∫ltimos meses. Itens com 5% ou mais das vendas ficam na Classe A, entre 1% e 5% na Classe B e os demais na Classe C." data-tooltip-position="top">?</span></h3>
            <p class="pareto-description">Calculamos quanto cada item representa sozinho do total vendido nos √∫ltimos 3 meses entre todos os produtos com sa√≠da. Itens com % Individual igual ou acima de 5% entram na Classe A, entre 1% e 5% ficam na Classe B e abaixo de 1% comp√µem a Classe C. A regra √© recalculada automaticamente conforme voc√™ aplica filtros, como fam√≠lia ou fornecedor.</p>
            <div id="paretoContent"></div>
        </div>
        <div class="gauges-container" id="gaugesContainer">
        </div>
        
        <div class="products-table">
            <div class="table-header">
                <h3 class="header-label">Detalhes dos Produtos <span class="info-icon has-tooltip" tabindex="0" aria-label="Detalhes dos Produtos" data-tooltip="Tabela com indicadores de estoque, consumo e classifica√ß√£o ABC de cada item ap√≥s aplicar os filtros ativos." data-tooltip-position="top">?</span></h3>
                <span id="tableCount">0 produtos exibidos</span>
            </div>
            <div class="table-container">
                <div class="table-scroll">
                    <table id="productsTable">
                    <thead>
                        <tr>
                            <th><span class="header-label">C√≥digo<span class="info-icon has-tooltip" tabindex="0" aria-label="C√≥digo" data-tooltip="Identificador √∫nico do item conforme cadastro interno.">?</span></span></th>
                            <th><span class="header-label">Fornecedor<span class="info-icon has-tooltip" tabindex="0" aria-label="Fornecedor" data-tooltip="Parceiro respons√°vel pelo fornecimento do item.">?</span></span></th>
                            <th><span class="header-label">Fam√≠lia<span class="info-icon has-tooltip" tabindex="0" aria-label="Fam√≠lia" data-tooltip="Categoria ou linha de produto utilizada para agrupar itens similares.">?</span></span></th>
                            <th><span class="header-label">Item<span class="info-icon has-tooltip" tabindex="0" aria-label="Item" data-tooltip="Descri√ß√£o comercial do produto.">?</span></span></th>
                            <th><span class="header-label">Est. 1-4<span class="info-icon has-tooltip" tabindex="0" aria-label="Estoque 1-4" data-tooltip="Saldo f√≠sico dispon√≠vel no estabelecimento 1-4 (Guarulhos).">?</span></span></th>
                            <th><span class="header-label">Est. 90-13<span class="info-icon has-tooltip" tabindex="0" aria-label="Estoque 90-13" data-tooltip="Saldo f√≠sico dispon√≠vel no estabelecimento 90-13 (Itaja√≠).">?</span></span></th>
                            <th><span class="header-label">Est. 90-15<span class="info-icon has-tooltip" tabindex="0" aria-label="Estoque 90-15" data-tooltip="Saldo f√≠sico dispon√≠vel no estabelecimento 90-15 (Garuva).">?</span></span></th>
                            <th><span class="header-label">Total<span class="info-icon has-tooltip" tabindex="0" aria-label="Total em estoque" data-tooltip="Soma do estoque dispon√≠vel em todos os estabelecimentos selecionados.">?</span></span></th>
                            <th><span class="header-label">Vendas 3M<span class="info-icon has-tooltip" tabindex="0" aria-label="Vendas 4 meses" data-tooltip="Quantidade vendida acumulada nos √∫ltimos 4 meses para o item, conforme informado na planilha." data-tooltip-position="top">?</span></span></th>
                            <th><span class="header-label">M√©dia 3M<span class="info-icon has-tooltip" tabindex="0" aria-label="M√©dia 3 meses" data-tooltip="M√©dia mensal das vendas dos √∫ltimos 3 meses, usada para estimar o consumo.">?</span></span></th>
                            <th><span class="header-label">Previs√£o<span class="info-icon has-tooltip" tabindex="0" aria-label="Previs√£o de ruptura" data-tooltip="Resumo da previs√£o de ruptura calculada para o item.">?</span></span></th>
                            <th><span class="header-label">Status<span class="info-icon has-tooltip" tabindex="0" aria-label="Status" data-tooltip="Classifica√ß√£o do risco atual com base nos meses de cobertura.">?</span></span></th>
                            <th><span class="header-label">Classe ABC<span class="info-icon has-tooltip" tabindex="0" aria-label="Classe ABC" data-tooltip="Classifica√ß√£o calculada pelo % Individual das vendas filtradas: itens com 5% ou mais das vendas ficam na Classe A, entre 1% e 5% na Classe B e os demais na Classe C.">?</span></span></th>
                        </tr>
                    </thead>
                    <tbody id="productsTableBody">
                    </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <button type="button" id="globalResetButton" class="floating-reset-button" onclick="handleGlobalReset()" aria-hidden="true">Limpar filtros</button>

    <!-- Modal de Exporta√ß√£o -->
    <div id="exportModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Exportar Dados</h2>
                <span class="close" onclick="closeExportModal()">&times;</span>
            </div>
            <div class="form-group">
                <label for="fileName">Nome do arquivo:</label>
                <input type="text" id="fileName" value="estoque_dados" placeholder="Digite o nome do arquivo">
            </div>
            <div class="form-group">
                <label for="fileFormat">Formato:</label>
                <select id="fileFormat">
                    <option value="xlsx">Excel (.xlsx)</option>
                    <option value="csv">CSV (.csv)</option>
                </select>
            </div>
            <div class="modal-buttons">
                <button class="btn-secondary" onclick="closeExportModal()">Cancelar</button>
                <button onclick="confirmExport()">Exportar</button>
            </div>
        </div>
    </div>

    <!-- Modal de Configura√ß√µes Preditivas -->
    <div id="predictionSettingsModal" class="modal" role="dialog" aria-modal="true" aria-hidden="true">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Configurar Limiares Preditivos</h2>
                <span class="close" role="button" tabindex="0" aria-label="Fechar configura√ß√µes" onclick="closePredictionSettings()" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();closePredictionSettings();}">&times;</span>
            </div>
            <div class="form-group">
                <label for="urgentDaysInput">Dias para alerta urgente:</label>
                <input type="number" id="urgentDaysInput" min="1" step="1" placeholder="Ex: 30">
            </div>
            <div class="form-group">
                <label for="warningDaysInput">Dias para alerta de aten√ß√£o:</label>
                <input type="number" id="warningDaysInput" min="1" step="1" placeholder="Ex: 60">
            </div>
            <div class="modal-buttons">
                <button class="btn-secondary" type="button" onclick="resetPredictionSettings()">Restaurar padr√£o</button>
                <button class="btn-secondary" type="button" onclick="closePredictionSettings()">Cancelar</button>
                <button type="button" onclick="savePredictionSettings()">Aplicar ajustes</button>
            </div>
        </div>
    </div>

    <!-- Modal de Hist√≥rico do Produto -->
    <div id="historyModal" class="modal" role="dialog" aria-modal="true" aria-hidden="true">
        <div class="modal-content history-modal-container">
            <div class="modal-header history-modal-header">
                <h2 id="historyModalTitle">Hist√≥rico do Produto</h2>
                <span class="close" role="button" tabindex="0" aria-label="Fechar hist√≥rico" onclick="closeHistoryModal()" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();closeHistoryModal();}">&times;</span>
            </div>
            <div class="history-modal-body" id="historyModalContent"></div>
        </div>
    </div>

    <div class="toast-container" id="toastContainer" aria-live="polite" aria-atomic="true"></div>

    <!-- Inclus√£o das bibliotecas -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="config.js"></script>
    <script src="search-intelligence.js"></script>
    <script src="conversation-parameters.js"></script>

    <script>
        // Vari√°veis globais
        let allProductsData = [];
        let filteredData = [];
        let currentFilter = 'all';
        let currentEstablishment = '';
        let searchTerm = '';
        let searchResultsCacheHtml = '';
        let searchResultsHidden = false;
        let activeSearchContext = null;
        let selectedSearchProduct = null;
        let predictionFilter = null;
        let selectedFamily = null;
        let selectedSupplier = null;
        let fileSystemSupported = false;
        let directoryHandle = null;
        let criticalFilterActive = false;
        let debugMode = false;
        let mappingDebugMode = false;
        let lastMappingInfo = null;
        let advancedStockFilter = '';
        let activeImportDescriptor = 'dados carregados';
        let lastImportedFileName = '';
        let lastImportedSheetName = '';

        const LOCAL_CONFIG_STORAGE_KEY = 'dashboardConfigOverrides';
        let localConfigOverrides = loadLocalConfigOverrides();

        const defaultFamilyAccentPalette = Object.freeze([
            '#FF6F61',
            '#2EC5B6',
            '#F2994A',
            '#9B51E0',
            '#56CCF2',
            '#27AE60',
            '#F2C94C',
            '#BB6BD9',
            '#EB5757',
            '#2D9CDB'
        ]);
        const defaultFamilyAccentOverrides = Object.freeze([
            ['borracha silicone', '#FF6F61'],
            ['borracha de silicone', '#FF6F61']
        ]);
        const familyAccentAssignments = new Map();
        const familyAccentConfiguration = initializeFamilyAccentConfig();
        const familyAccentPalette = familyAccentConfiguration.palette;
        const familyAccentOverrides = familyAccentConfiguration.overrides;
        const familyAccentFallback = familyAccentConfiguration.fallback;
        // Faixas do % individual das vendas usadas para classificar os itens
        const abcIndividualThresholds = Object.freeze({
            classA: 0.05,
            classB: 0.01
        });
        const coverageSegmentThresholds = Object.freeze({
            critical: 2,
            lowUpper: 6
        });
        const riskChartInstances = {};
        const riskChartMaxSegments = 5;
        let activeRiskSelection = null;
        let abcClassificationMap = new Map();
        let tooltipElement = null;
        let activeTooltipTarget = null;
        let tooltipHideTimeout = null;
        let riskChartTooltipElement = null;
        let activeRiskChartTooltip = null;

        const monthDetectionPatterns = Object.freeze([
            { order: 0, keywords: ['JANEIRO', 'JAN'] },
            { order: 1, keywords: ['FEVEREIRO', 'FEV'] },
            { order: 2, keywords: ['MARCO', 'MAR√áO', 'MAR'] },
            { order: 3, keywords: ['ABRIL', 'ABR'] },
            { order: 4, keywords: ['MAIO', 'MAI'] },
            { order: 5, keywords: ['JUNHO', 'JUN'] },
            { order: 6, keywords: ['JULHO', 'JUL'] },
            { order: 7, keywords: ['AGOSTO', 'AGO'] },
            { order: 8, keywords: ['SETEMBRO', 'SET', 'SEP'] },
            { order: 9, keywords: ['OUTUBRO', 'OUT', 'OCT'] },
            { order: 10, keywords: ['NOVEMBRO', 'NOV'] },
            { order: 11, keywords: ['DEZEMBRO', 'DEZ', 'DEC'] }
        ]);

        function normalizeHeaderForMonth(header) {
            if (header === null || typeof header === 'undefined') {
                return '';
            }

            return header.toString()
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '')
                .toUpperCase();
        }

        function detectMonthInfo(header) {
            const normalizedHeader = normalizeHeaderForMonth(header);
            if (!normalizedHeader) {
                return null;
            }

            for (const pattern of monthDetectionPatterns) {
                for (const keyword of pattern.keywords) {
                    if (normalizedHeader.includes(keyword)) {
                        return {
                            order: pattern.order,
                            keyword,
                            normalizedHeader
                        };
                    }
                }
            }

            return null;
        }

        function normalizeFamilyKey(family) {
            return (family || '').toString().trim().toLowerCase();
        }

        function sanitizeHexColor(color) {
            if (typeof color !== 'string') {
                return null;
            }

            const trimmed = color.trim();
            if (!trimmed) {
                return null;
            }

            const hex = trimmed.replace(/^#/, '');
            if (!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$/.test(hex)) {
                return null;
            }

            const normalized = hex.length === 3
                ? hex.split('').map(function(char) { return char + char; }).join('')
                : hex.toLowerCase();

            return `#${normalized}`;
        }

        function componentToHex(value) {
            const clamped = Math.min(255, Math.max(0, Math.round(value)));
            return clamped.toString(16).padStart(2, '0');
        }

        function shiftHexColor(color, amount) {
            const base = sanitizeHexColor(color);
            if (!base) {
                return null;
            }

            const normalized = base.slice(1);
            const r = parseInt(normalized.slice(0, 2), 16);
            const g = parseInt(normalized.slice(2, 4), 16);
            const b = parseInt(normalized.slice(4, 6), 16);
            const delta = Math.round(255 * amount);

            const newR = componentToHex(r + delta);
            const newG = componentToHex(g + delta);
            const newB = componentToHex(b + delta);

            return `#${newR}${newG}${newB}`;
        }

        function getReadableTextColor(color) {
            const base = sanitizeHexColor(color);
            if (!base) {
                return '#ffffff';
            }

            const r = parseInt(base.slice(1, 3), 16);
            const g = parseInt(base.slice(3, 5), 16);
            const b = parseInt(base.slice(5, 7), 16);
            const yiq = (r * 299 + g * 587 + b * 114) / 1000;

            return yiq >= 160 ? '#1f2933' : '#ffffff';
        }

        function buildFamilyAccent(baseColor) {
            const sanitizedBase = sanitizeHexColor(baseColor) || familyAccentFallback;
            const surface = shiftHexColor(sanitizedBase, -0.1) || sanitizedBase;
            const chipBackground = shiftHexColor(sanitizedBase, 0.14) || sanitizedBase;
            const textColor = getReadableTextColor(surface);
            const subTextColor = textColor === '#ffffff'
                ? 'rgba(255, 255, 255, 0.85)'
                : 'rgba(31, 41, 51, 0.72)';

            return {
                surface,
                text: textColor,
                subText: subTextColor,
                chipBackground,
                chipText: getReadableTextColor(chipBackground)
            };
        }

        function getFamilyAccent(family) {
            const key = normalizeFamilyKey(family);
            if (!key) {
                return null;
            }

            if (familyAccentAssignments.has(key)) {
                return familyAccentAssignments.get(key);
            }

            const overrideColor = familyAccentOverrides.get(key);
            const paletteIndex = familyAccentAssignments.size % familyAccentPalette.length;
            const baseColor = overrideColor || familyAccentPalette[paletteIndex] || familyAccentFallback;
            const accent = buildFamilyAccent(baseColor);
            familyAccentAssignments.set(key, accent);

            return accent;
        }

        function initializeFamilyAccentConfig() {
            const fallbackDefault = '#1d396e';
            let fallbackColor = sanitizeHexColor(fallbackDefault) || '#1d396e';

            const sanitizedDefaultPalette = defaultFamilyAccentPalette
                .map(sanitizeHexColor)
                .filter(Boolean);

            const overrides = new Map();
            defaultFamilyAccentOverrides.forEach(function(entry) {
                if (!Array.isArray(entry) || entry.length < 2) {
                    return;
                }

                const familyName = entry[0];
                const color = sanitizeHexColor(entry[1]);
                const normalizedName = normalizeFamilyKey(familyName);

                if (normalizedName && color) {
                    overrides.set(normalizedName, color);
                }
            });

            const globalConfig = (typeof window !== 'undefined' && window.DASHBOARD_CONFIG && typeof window.DASHBOARD_CONFIG === 'object')
                ? window.DASHBOARD_CONFIG.familyColors
                : null;

            let palette = sanitizedDefaultPalette.slice();

            if (globalConfig && typeof globalConfig === 'object') {
                if (Array.isArray(globalConfig.palette)) {
                    const sanitizedUserPalette = globalConfig.palette
                        .map(sanitizeHexColor)
                        .filter(Boolean);

                    if (sanitizedUserPalette.length > 0) {
                        palette = sanitizedUserPalette;
                    }
                }

                if (globalConfig.overrides && typeof globalConfig.overrides === 'object') {
                    Object.keys(globalConfig.overrides).forEach(function(familyName) {
                        const normalizedName = normalizeFamilyKey(familyName);
                        const color = sanitizeHexColor(globalConfig.overrides[familyName]);

                        if (normalizedName && color) {
                            overrides.set(normalizedName, color);
                        }
                    });
                }

                if (globalConfig.fallback) {
                    const sanitizedFallback = sanitizeHexColor(globalConfig.fallback);
                    if (sanitizedFallback) {
                        fallbackColor = sanitizedFallback;
                    }
                }
            }

            if (!Array.isArray(palette) || palette.length === 0) {
                palette = sanitizedDefaultPalette.length > 0 ? sanitizedDefaultPalette : [fallbackColor];
            }

            if (palette.length === 0) {
                palette = [fallbackColor];
            }

            return {
                palette: Object.freeze(palette.slice()),
                overrides,
                fallback: fallbackColor
            };
        }

        function isMonthHeader(header) {
            return detectMonthInfo(header) !== null;
        }

        function hasMeaningfulValue(value) {
            return value !== null && typeof value !== 'undefined' && String(value).trim() !== '';
        }

        function sortMonthlyValues(values) {
            if (!Array.isArray(values)) {
                return [];
            }

            return values.slice().sort(function(a, b) {
                const infoA = detectMonthInfo(a && a.label);
                const infoB = detectMonthInfo(b && b.label);
                const orderA = infoA ? infoA.order : Number.MAX_SAFE_INTEGER;
                const orderB = infoB ? infoB.order : Number.MAX_SAFE_INTEGER;

                if (orderA === orderB) {
                    const labelA = (a && a.label) ? a.label.toString() : '';
                    const labelB = (b && b.label) ? b.label.toString() : '';
                    return labelA.localeCompare(labelB, 'pt-BR', { sensitivity: 'base', numeric: true });
                }

                return orderA - orderB;
            });
        }

        function cloneMonthlyValues(values) {
            if (!Array.isArray(values)) {
                return [];
            }

            return values.map(function(entry) {
                if (!entry || typeof entry !== 'object') {
                    return { label: '', value: 0, rawValue: '' };
                }

                const numericValue = Number(entry.value);
                const parsedValue = Number.isFinite(numericValue) ? numericValue : parseNumber(entry.value);
                const rawValue = typeof entry.rawValue !== 'undefined' ? entry.rawValue : entry.value;

                return {
                    label: entry.label ? entry.label.toString() : '',
                    value: Number.isFinite(parsedValue) ? parsedValue : 0,
                    rawValue: rawValue
                };
            });
        }

        function aggregateMonthlyValues(existingValues, newValues) {
            const aggregated = new Map();

            (Array.isArray(existingValues) ? existingValues : []).forEach(function(entry) {
                if (!entry || !entry.label) return;
                aggregated.set(entry.label, {
                    label: entry.label,
                    value: Number.isFinite(entry.value) ? entry.value : parseNumber(entry.value),
                    rawValue: typeof entry.rawValue !== 'undefined' ? entry.rawValue : entry.value
                });
            });

            (Array.isArray(newValues) ? newValues : []).forEach(function(entry) {
                if (!entry || !entry.label) return;
                aggregated.set(entry.label, {
                    label: entry.label,
                    value: Number.isFinite(entry.value) ? entry.value : parseNumber(entry.value),
                    rawValue: typeof entry.rawValue !== 'undefined' ? entry.rawValue : entry.value
                });
            });

            return sortMonthlyValues(Array.from(aggregated.values()));
        }

        function createHistoryEntry(product, sheetName) {
            const months = cloneMonthlyValues(product.sheetMonthlyValues);
            const totalStock = Number(product.stock14 || 0) + Number(product.stock9013 || 0) + Number(product.stock9015 || 0);
            const coverageValue = getCoverageValue(product);
            const historyCoverageSource = resolveCoverageSource(product);

            return {
                sheetName: sheetName || '',
                months: months,
                totals: {
                    stock14: Number(product.stock14) || 0,
                    stock9013: Number(product.stock9013) || 0,
                    stock9015: Number(product.stock9015) || 0,
                    totalStock: Number.isFinite(totalStock) ? totalStock : 0,
                    vendas4M: Number(product.vendas4M) || 0,
                    media3M: Number(product.media3M) || 0,
                    cobertura: Number.isFinite(coverageValue) ? coverageValue : 0
                },
                coverageSource: historyCoverageSource
            };
        }

        function buildFallbackMonthlyValues(product) {
            if (!product || typeof product !== 'object') {
                return [];
            }

            const fallback = [];

            Object.keys(product).forEach(function(key) {
                if (!key) return;
                const info = detectMonthInfo(key);
                if (!info) return;

                const value = product[key];
                if (!hasMeaningfulValue(value)) return;

                const numericValue = parseNumber(value);
                fallback.push({
                    label: key.toString().replace(/_/g, ' ').toUpperCase(),
                    value: Number.isFinite(numericValue) ? numericValue : 0,
                    rawValue: value
                });
            });

            return sortMonthlyValues(fallback);
        }

        function normalizeHistoryEntry(entry) {
            if (!entry || typeof entry !== 'object') {
                return {
                    sheetName: '',
                    months: [],
                    totals: {
                        stock14: 0,
                        stock9013: 0,
                        stock9015: 0,
                        totalStock: 0,
                        vendas4M: 0,
                        media3M: 0,
                        cobertura: 0
                    },
                    coverageSource: 'none'
                };
            }

            const normalizedTotals = Object.assign({
                stock14: 0,
                stock9013: 0,
                stock9015: 0,
                totalStock: 0,
                vendas4M: 0,
                media3M: 0,
                cobertura: 0
            }, entry.totals || {});

            const normalizedCoverageSource = entry.coverageSource || 'none';

            normalizedTotals.stock14 = Number.isFinite(Number(normalizedTotals.stock14))
                ? Number(normalizedTotals.stock14)
                : parseNumber(normalizedTotals.stock14);
            normalizedTotals.stock9013 = Number.isFinite(Number(normalizedTotals.stock9013))
                ? Number(normalizedTotals.stock9013)
                : parseNumber(normalizedTotals.stock9013);
            normalizedTotals.stock9015 = Number.isFinite(Number(normalizedTotals.stock9015))
                ? Number(normalizedTotals.stock9015)
                : parseNumber(normalizedTotals.stock9015);
            normalizedTotals.vendas4M = Number.isFinite(Number(normalizedTotals.vendas4M))
                ? Number(normalizedTotals.vendas4M)
                : parseNumber(normalizedTotals.vendas4M);
            normalizedTotals.media3M = Number.isFinite(Number(normalizedTotals.media3M))
                ? Number(normalizedTotals.media3M)
                : parseNumber(normalizedTotals.media3M);
            normalizedTotals.cobertura = Number.isFinite(Number(normalizedTotals.cobertura))
                ? Number(normalizedTotals.cobertura)
                : parseNumber(normalizedTotals.cobertura);
            normalizedTotals.totalStock = Number.isFinite(Number(normalizedTotals.totalStock))
                ? Number(normalizedTotals.totalStock)
                : (normalizedTotals.stock14 + normalizedTotals.stock9013 + normalizedTotals.stock9015);

            return {
                sheetName: entry.sheetName || '',
                months: sortMonthlyValues(cloneMonthlyValues(entry.months)),
                totals: normalizedTotals,
                coverageSource: normalizedCoverageSource
            };
        }

        function ensureProductHistoryStructure(product) {
            if (!product || typeof product !== 'object') {
                return product;
            }

            if (Array.isArray(product.monthlyValues) && product.monthlyValues.length > 0) {
                product.monthlyValues = sortMonthlyValues(cloneMonthlyValues(product.monthlyValues));
            } else {
                product.monthlyValues = buildFallbackMonthlyValues(product);
            }

            if (Array.isArray(product.importHistory) && product.importHistory.length > 0) {
                product.importHistory = product.importHistory.map(normalizeHistoryEntry);
            } else {
                product.importHistory = [];
            }

            const hasCobertura = Number.isFinite(product.cobertura);
            const hasStockMonths = Number.isFinite(product.stockMonths);

            if (!product.coverageSource || product.coverageSource === 'stockMonths' || product.coverageSource === 'cobertura') {
                if (hasCobertura) {
                    product.coverageSource = 'cobertura';
                } else if (hasStockMonths) {
                    product.coverageSource = 'stockMonths';
                } else {
                    product.coverageSource = 'none';
                }
            }

            return product;
        }

        function formatHistoryDisplayValue(entry) {
            if (!entry || typeof entry !== 'object') {
                return '--';
            }

            const raw = entry.rawValue;
            if (typeof raw === 'string') {
                const trimmedRaw = raw.trim();
                if (!trimmedRaw || trimmedRaw === '--') {
                    return '--';
                }

                if (/^-?[0-9.,]+$/.test(trimmedRaw)) {
                    const numeric = parseNumber(trimmedRaw);
                    return Number.isFinite(numeric)
                        ? numeric.toLocaleString('pt-BR')
                        : escapeTooltip(trimmedRaw);
                }

                return escapeTooltip(trimmedRaw);
            }

            if (typeof raw === 'number' && Number.isFinite(raw)) {
                return raw.toLocaleString('pt-BR');
            }

            if (Number.isFinite(entry.value)) {
                return entry.value.toLocaleString('pt-BR');
            }

            return '--';
        }

        function ensureTooltipElement() {
            if (!tooltipElement) {
                tooltipElement = document.createElement('div');
                tooltipElement.className = 'tooltip-bubble';
                tooltipElement.setAttribute('role', 'tooltip');
                tooltipElement.setAttribute('aria-hidden', 'true');
                tooltipElement.dataset.position = 'bottom';
                document.body.appendChild(tooltipElement);
            }
        }

        function positionTooltip(target) {
            if (!tooltipElement || !target) {
                return;
            }

            const rect = target.getBoundingClientRect();
            const desiredPosition = target.getAttribute('data-tooltip-position');
            const prefersTop = desiredPosition !== 'bottom';
            tooltipElement.style.maxWidth = `min(320px, ${Math.max(200, window.innerWidth - 32)}px)`;

            const tooltipRect = tooltipElement.getBoundingClientRect();
            const scrollY = window.scrollY || document.documentElement.scrollTop || 0;
            const scrollX = window.scrollX || document.documentElement.scrollLeft || 0;
            const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
            const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
            const minTop = scrollY + 8;
            const maxTop = scrollY + viewportHeight - tooltipRect.height - 8;

            const computeTop = function(position) {
                const referenceTop = rect.top + scrollY;
                const referenceBottom = rect.bottom + scrollY;
                return position === 'top'
                    ? referenceTop - tooltipRect.height - 10
                    : referenceBottom + 10;
            };

            let position = prefersTop ? 'top' : 'bottom';
            let top = computeTop(position);

            if (top < minTop) {
                position = 'bottom';
                top = computeTop(position);
            }

            if (top > maxTop) {
                position = 'top';
                top = computeTop(position);
            }

            top = Math.min(Math.max(top, minTop), maxTop);

            const centerX = rect.left + scrollX + (rect.width / 2);
            let left = centerX - (tooltipRect.width / 2);
            const minLeft = scrollX + 8;
            const maxLeft = scrollX + viewportWidth - tooltipRect.width - 8;
            left = Math.min(Math.max(left, minLeft), maxLeft);

            tooltipElement.dataset.position = position;
            tooltipElement.style.top = `${top}px`;
            tooltipElement.style.left = `${left}px`;

            const arrowLeft = centerX - left;
            tooltipElement.style.setProperty('--tooltip-arrow-left', `${Math.min(Math.max(arrowLeft, 12), tooltipRect.width - 12)}px`);
        }

        function showTooltip(target) {
            if (!target || !target.getAttribute('data-tooltip')) {
                return;
            }

            ensureTooltipElement();
            tooltipElement.textContent = target.getAttribute('data-tooltip');
            tooltipElement.setAttribute('aria-hidden', 'false');
            tooltipElement.classList.add('visible');
            activeTooltipTarget = target;
            positionTooltip(target);
        }

        function hideTooltip() {
            if (!tooltipElement) {
                return;
            }

            tooltipElement.classList.remove('visible');
            tooltipElement.setAttribute('aria-hidden', 'true');
            activeTooltipTarget = null;
        }

        function handleTooltipEnter(event) {
            clearTimeout(tooltipHideTimeout);
            showTooltip(event.currentTarget);
        }

        function handleTooltipLeave() {
            clearTimeout(tooltipHideTimeout);
            tooltipHideTimeout = setTimeout(hideTooltip, 80);
        }

        function handleTooltipFocus(event) {
            clearTimeout(tooltipHideTimeout);
            showTooltip(event.currentTarget);
        }

        function handleTooltipBlur() {
            clearTimeout(tooltipHideTimeout);
            hideTooltip();
        }

        function bindTooltip(target) {
            if (!target || target.dataset.tooltipBound === 'true') {
                return;
            }

            target.dataset.tooltipBound = 'true';
            target.addEventListener('mouseenter', handleTooltipEnter);
            target.addEventListener('mouseleave', handleTooltipLeave);
            target.addEventListener('focus', handleTooltipFocus);
            target.addEventListener('blur', handleTooltipBlur);
        }

        function initializeTooltips(root) {
            const scope = root || document;
            const elements = scope.querySelectorAll('.has-tooltip');
            elements.forEach(bindTooltip);
        }

        function ensureRiskChartTooltipElement() {
            if (!riskChartTooltipElement) {
                riskChartTooltipElement = document.createElement('div');
                riskChartTooltipElement.className = 'tooltip-bubble prediction-chart-tooltip';
                riskChartTooltipElement.setAttribute('role', 'tooltip');
                riskChartTooltipElement.setAttribute('aria-hidden', 'true');
                riskChartTooltipElement.dataset.position = 'top';
                document.body.appendChild(riskChartTooltipElement);
            }

            return riskChartTooltipElement;
        }

        function hideRiskChartTooltip() {
            if (riskChartTooltipElement) {
                riskChartTooltipElement.classList.remove('visible');
                riskChartTooltipElement.setAttribute('aria-hidden', 'true');
            }

            activeRiskChartTooltip = null;
        }

        function positionRiskChartTooltip() {
            if (!activeRiskChartTooltip || !riskChartTooltipElement || !activeRiskChartTooltip.chart) {
                return;
            }

            const chart = activeRiskChartTooltip.chart;
            const canvas = chart.canvas;
            if (!canvas) {
                return;
            }

            const canvasRect = canvas.getBoundingClientRect();
            const scrollY = window.scrollY || document.documentElement.scrollTop || 0;
            const scrollX = window.scrollX || document.documentElement.scrollLeft || 0;
            const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
            const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
            const pointerLeft = scrollX + canvasRect.left + activeRiskChartTooltip.caretX;
            const pointerTop = scrollY + canvasRect.top + activeRiskChartTooltip.caretY;

            riskChartTooltipElement.style.maxWidth = `min(320px, ${Math.max(200, viewportWidth - 32)}px)`;

            const tooltipRect = riskChartTooltipElement.getBoundingClientRect();
            const minTop = scrollY + 8;
            const maxTop = scrollY + viewportHeight - tooltipRect.height - 8;
            const preferred = activeRiskChartTooltip.preferredPosition === 'bottom' ? 'bottom' : 'top';

            const computeTop = function(position) {
                return position === 'top'
                    ? pointerTop - tooltipRect.height - 16
                    : pointerTop + 16;
            };

            let position = preferred;
            let top = computeTop(position);

            if (top < minTop) {
                position = 'bottom';
                top = computeTop(position);
            }

            if (top > maxTop) {
                position = 'top';
                top = computeTop(position);
            }

            top = Math.min(Math.max(top, minTop), maxTop);

            let left = pointerLeft - (tooltipRect.width / 2);
            const minLeft = scrollX + 8;
            const maxLeft = scrollX + viewportWidth - tooltipRect.width - 8;
            left = Math.min(Math.max(left, minLeft), maxLeft);

            riskChartTooltipElement.dataset.position = position;
            riskChartTooltipElement.style.top = `${top}px`;
            riskChartTooltipElement.style.left = `${left}px`;

            const arrowLeft = pointerLeft - left;
            riskChartTooltipElement.style.setProperty('--tooltip-arrow-left', `${Math.min(Math.max(arrowLeft, 12), tooltipRect.width - 12)}px`);
        }

        function showRiskChartTooltip(chart, text, caretX, caretY, preferredPosition) {
            if (!chart || !text) {
                hideRiskChartTooltip();
                return;
            }

            const element = ensureRiskChartTooltipElement();
            element.textContent = text;
            element.setAttribute('aria-hidden', 'false');
            element.classList.add('visible');

            activeRiskChartTooltip = {
                chart: chart,
                caretX: caretX,
                caretY: caretY,
                preferredPosition: preferredPosition === 'bottom' ? 'bottom' : 'top'
            };

            positionRiskChartTooltip();
        }

        function renderRiskChartTooltip(context) {
            if (!context || !context.chart) {
                hideRiskChartTooltip();
                return;
            }

            const tooltip = context.tooltip;
            if (!tooltip || tooltip.opacity === 0) {
                hideRiskChartTooltip();
                return;
            }

            const dataPoint = tooltip.dataPoints && tooltip.dataPoints[0] ? tooltip.dataPoints[0] : null;
            if (!dataPoint) {
                hideRiskChartTooltip();
                return;
            }

            const chart = context.chart;
            const segmentIndex = dataPoint.dataIndex;
            const segment = chart.$riskSegments && Number.isInteger(segmentIndex)
                ? chart.$riskSegments[segmentIndex]
                : null;
            const total = Number.isFinite(chart.$riskTotalSegmentsCount)
                ? chart.$riskTotalSegmentsCount
                : 0;
            const value = Number.isFinite(dataPoint.parsed) ? dataPoint.parsed : dataPoint.raw;
            const count = Number.isFinite(value) ? value : 0;
            const percent = total > 0 ? (count / total) * 100 : 0;
            const percentText = percent >= 10 ? percent.toFixed(0) : percent.toFixed(1);
            const label = segment && segment.label ? segment.label : dataPoint.label;
            const itemLabel = count === 1 ? 'item' : 'itens';
            const productTooltip = segment && typeof segment.productTooltip === 'string'
                ? segment.productTooltip.trim()
                : '';
            const tooltipParts = [`${label}: ${count} ${itemLabel} (${percentText}%)`];
            if (productTooltip) {
                tooltipParts.push(productTooltip);
            }
            showRiskChartTooltip(chart, tooltipParts.join(' ‚Ä¢ '), tooltip.caretX, tooltip.caretY, tooltip.yAlign);
        }

        window.addEventListener('scroll', function() {
            if (activeTooltipTarget) {
                positionTooltip(activeTooltipTarget);
            }

            positionRiskChartTooltip();
        }, true);

        window.addEventListener('resize', function() {
            if (activeTooltipTarget) {
                positionTooltip(activeTooltipTarget);
            }

            positionRiskChartTooltip();
        });

        // Fun√ß√£o de log para debug
        function debugLog(message, type) {
            type = type || 'info';
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${type.toUpperCase()}: ${message}`;
            
            console.log(logMessage);
            
            if (debugMode) {
                const debugDiv = document.getElementById('debugInfo');
                if (debugDiv) {
                    debugDiv.innerHTML += logMessage + '<br>';
                    debugDiv.scrollTop = debugDiv.scrollHeight;
                }
            }
        }

        function toggleDebug() {
            debugMode = !debugMode;
            const debugDiv = document.getElementById('debugInfo');
            if (debugDiv) {
                debugDiv.style.display = debugMode ? 'block' : 'none';
                if (debugMode) {
                    debugDiv.innerHTML = '<strong>üêõ DEBUG MODE ATIVADO</strong><br>';
                    debugLog('Debug mode ativado');
                }
            }
        }

        function toggleMappingDebug() {
            mappingDebugMode = !mappingDebugMode;
            const mappingDiv = document.getElementById('mappingDebug');
            if (mappingDiv) {
                mappingDiv.style.display = mappingDebugMode ? 'block' : 'none';
                if (mappingDebugMode && lastMappingInfo) {
                    showMappingInfo(lastMappingInfo);
                }
            }
        }

        function showMappingInfo(mappingInfo) {
            const mappingDiv = document.getElementById('mappingDebug');
            if (!mappingDiv || !mappingDebugMode) return;

            let html = '<strong>üìã INFORMA√á√ïES DE MAPEAMENTO DE COLUNAS</strong><br><br>';
            html += `<strong>Colunas encontradas na planilha:</strong><br>`;
            mappingInfo.headers.forEach((header, index) => {
                html += `[${index}] "${header}"<br>`;
            });

            html += '<br><strong>Mapeamento aplicado:</strong><br>';
            for (const [field, index] of Object.entries(mappingInfo.mapping)) {
                const header = mappingInfo.headers[index] || '√çNDICE INV√ÅLIDO';
                const status = mappingInfo.headers[index] ? '‚úÖ' : '‚ùå';
                html += `${field} ‚Üí [${index}] "${header}" ${status}<br>`;
            }

            if (mappingInfo.warnings.length > 0) {
                html += '<br><strong>‚ö†Ô∏è Avisos:</strong><br>';
                mappingInfo.warnings.forEach(warning => {
                    html += `${warning}<br>`;
                });
            }

            mappingDiv.innerHTML = html;
        }

        function getNestedConfigValue(source, keys) {
            if (!source || typeof source !== 'object' || !Array.isArray(keys)) {
                return undefined;
            }

            let current = source;
            for (const key of keys) {
                if (current && typeof current === 'object' && key in current) {
                    current = current[key];
                } else {
                    return undefined;
                }
            }

            return current;
        }

        function setNestedConfigValue(target, keys, value) {
            if (!target || typeof target !== 'object' || !Array.isArray(keys) || keys.length === 0) {
                return;
            }

            let current = target;
            for (let index = 0; index < keys.length - 1; index++) {
                const key = keys[index];
                if (!current[key] || typeof current[key] !== 'object') {
                    current[key] = {};
                }
                current = current[key];
            }

            current[keys[keys.length - 1]] = value;
        }

        function loadLocalConfigOverrides() {
            if (typeof localStorage === 'undefined') {
                return {};
            }

            try {
                const stored = localStorage.getItem(LOCAL_CONFIG_STORAGE_KEY);
                if (!stored) {
                    return {};
                }

                const parsed = JSON.parse(stored);
                return parsed && typeof parsed === 'object' ? parsed : {};
            } catch (error) {
                console.warn('N√£o foi poss√≠vel carregar overrides locais:', error);
                return {};
            }
        }

        function saveLocalConfigOverrides() {
            if (typeof localStorage === 'undefined') {
                return;
            }

            try {
                if (localConfigOverrides && Object.keys(localConfigOverrides).length > 0) {
                    localStorage.setItem(LOCAL_CONFIG_STORAGE_KEY, JSON.stringify(localConfigOverrides));
                } else {
                    localStorage.removeItem(LOCAL_CONFIG_STORAGE_KEY);
                }
            } catch (error) {
                console.warn('N√£o foi poss√≠vel salvar overrides locais:', error);
            }
        }

        function setLocalConfigValue(path, value) {
            if (!path) {
                return;
            }

            if (!localConfigOverrides || typeof localConfigOverrides !== 'object') {
                localConfigOverrides = {};
            }

            const keys = path.split('.');
            if (!Array.isArray(keys) || keys.length === 0) {
                return;
            }

            if (value === null || typeof value === 'undefined' || value === '') {
                let current = localConfigOverrides;
                const stack = [];

                for (let index = 0; index < keys.length - 1; index++) {
                    const key = keys[index];
                    if (!current[key] || typeof current[key] !== 'object') {
                        return;
                    }
                    stack.push({ parent: current, key });
                    current = current[key];
                }

                delete current[keys[keys.length - 1]];

                for (let index = stack.length - 1; index >= 0; index--) {
                    const { parent, key } = stack[index];
                    if (parent[key] && typeof parent[key] === 'object' && Object.keys(parent[key]).length === 0) {
                        delete parent[key];
                    }
                }
            } else {
                setNestedConfigValue(localConfigOverrides, keys, value);
            }

            saveLocalConfigOverrides();
        }

        function clearLocalConfigOverrides() {
            localConfigOverrides = {};
            saveLocalConfigOverrides();
        }

        function getConfigValue(path, fallback) {
            if (!path) {
                return fallback;
            }

            const keyPath = path.split('.');
            const overrideValue = getNestedConfigValue(localConfigOverrides, keyPath);
            if (typeof overrideValue !== 'undefined') {
                return overrideValue;
            }

            if (typeof getConfig === 'function') {
                const value = getConfig(path);
                if (typeof value !== 'undefined') {
                    return value;
                }
            }

            const candidateConfigs = [window.DASHBOARD_CONFIG, window.dashboardConfig];
            for (const config of candidateConfigs) {
                const value = getNestedConfigValue(config, keyPath);
                if (typeof value !== 'undefined') {
                    return value;
                }
            }

            return fallback;
        }

        function getPredictionSettings() {
            const defaults = { urgentDays: 30, warningDays: 60 };
            const configValues = getConfigValue('predictions', {}) || {};
            const urgentConfig = Number(configValues.urgentDays);
            const warningConfig = Number(configValues.warningDays);

            const urgentDays = Number.isFinite(urgentConfig) && urgentConfig > 0
                ? urgentConfig
                : defaults.urgentDays;

            let warningDays = Number.isFinite(warningConfig) && warningConfig > 0
                ? warningConfig
                : defaults.warningDays;

            if (warningDays < urgentDays) {
                warningDays = urgentDays;
            }

            return {
                urgentDays: urgentDays,
                warningDays: warningDays
            };
        }

        function calculateDailyDemand(product) {
            const monthlyAverage = product.media3M && product.media3M > 0
                ? product.media3M
                : (product.vendas4M && product.vendas4M > 0 ? product.vendas4M / 4 : 0);

            if (monthlyAverage > 0) {
                return monthlyAverage / 30;
            }

            if (product.stockMonths && product.stockMonths > 0) {
                const totalStock = (product.stock14 || 0) + (product.stock9013 || 0) + (product.stock9015 || 0);
                const inferredDaily = totalStock / (product.stockMonths * 30);
                return isFinite(inferredDaily) && inferredDaily > 0 ? inferredDaily : 0;
            }

            return 0;
        }

        function getCoverageInfo(product) {
            const stockAvailable = getProductStock(product);
            const dailyDemand = calculateDailyDemand(product);

            if (stockAvailable <= 0) {
                return {
                    stockAvailable,
                    dailyDemand,
                    daysToDepletion: 0,
                    hasDemand: dailyDemand > 0,
                    outOfStock: true
                };
            }

            if (dailyDemand <= 0) {
                return {
                    stockAvailable,
                    dailyDemand,
                    daysToDepletion: null,
                    hasDemand: false,
                    outOfStock: false
                };
            }

            return {
                stockAvailable,
                dailyDemand,
                daysToDepletion: stockAvailable / dailyDemand,
                hasDemand: true,
                outOfStock: false
            };
        }

        function formatStatValue(value, digits = 1) {
            if (value === null || typeof value === 'undefined' || Number.isNaN(value)) {
                return '--';
            }

            return new Intl.NumberFormat('pt-BR', {
                minimumFractionDigits: digits,
                maximumFractionDigits: digits
            }).format(value);
        }

        function formatIntegerValue(value) {
            if (!Number.isFinite(value)) {
                return '0';
            }

            return Math.round(value).toLocaleString('pt-BR');
        }

        function formatWeightDisplay(value) {
            if (!Number.isFinite(value)) {
                return '--';
            }

            const rounded = Math.round(value);
            return `${rounded.toLocaleString('pt-BR')} kg`;
        }

        function formatCoverageDisplay(value) {
            if (!Number.isFinite(value)) {
                return {
                    displayValue: '--',
                    unitLabel: '',
                    unitType: null
                };
            }

            if (value === 0) {
                return {
                    displayValue: '0',
                    unitLabel: 'meses',
                    unitType: 'months'
                };
            }

            const months = value;
            const totalDays = months * 30;
            const absDays = Math.abs(totalDays);

            const formatNumber = function(number, maxFractionDigits) {
                if (!Number.isFinite(number)) {
                    return '--';
                }

                const absNumber = Math.abs(number);
                let digits;
                if (absNumber >= 100) {
                    digits = 0;
                } else if (absNumber >= 10) {
                    digits = Math.min(maxFractionDigits, 1);
                } else {
                    digits = maxFractionDigits;
                }

                const factor = Math.pow(10, digits);
                const rounded = factor > 0 ? Math.round(number * factor) / factor : Math.round(number);
                const hasFraction = Math.abs(rounded - Math.round(rounded)) > 1e-6;
                const fractionDigits = hasFraction ? digits : 0;

                return new Intl.NumberFormat('pt-BR', {
                    minimumFractionDigits: fractionDigits,
                    maximumFractionDigits: fractionDigits
                }).format(rounded);
            };

            const isApproximatelyOne = function(number) {
                return Math.abs(Math.abs(number) - 1) < 1e-6;
            };

            if (absDays >= 365) {
                const years = months / 12;
                return {
                    displayValue: formatNumber(years, 1),
                    unitLabel: Math.abs(years) >= 2 ? 'anos' : 'ano',
                    unitType: 'years'
                };
            }

            if (absDays >= 30) {
                return {
                    displayValue: formatNumber(months, 1),
                    unitLabel: Math.abs(months) >= 2 ? 'meses' : 'm√™s',
                    unitType: 'months'
                };
            }

            if (absDays >= 1) {
                return {
                    displayValue: formatNumber(totalDays, 1),
                    unitLabel: isApproximatelyOne(totalDays) ? 'dia' : 'dias',
                    unitType: 'days'
                };
            }

            const totalHours = totalDays * 24;
            const absHours = Math.abs(totalHours);

            if (absHours >= 1) {
                return {
                    displayValue: formatNumber(totalHours, 1),
                    unitLabel: isApproximatelyOne(totalHours) ? 'hora' : 'horas',
                    unitType: 'hours'
                };
            }

            const totalMinutes = Math.round(totalHours * 60);
            return {
                displayValue: new Intl.NumberFormat('pt-BR').format(totalMinutes),
                unitLabel: Math.abs(totalMinutes) === 1 ? 'minuto' : 'minutos',
                unitType: 'minutes'
            };
        }

        function formatCoverageThresholdLabel(months) {
            const display = formatCoverageDisplay(months);
            if (!display || display.displayValue === '--') {
                return '--';
            }

            return display.unitLabel
                ? `${display.displayValue} ${display.unitLabel}`.trim()
                : display.displayValue;
        }

        function toFiniteNumber(value) {
            if (typeof value === 'number') {
                return Number.isFinite(value) ? value : null;
            }

            if (typeof value === 'string') {
                const trimmed = value.trim();
                if (trimmed === '') {
                    return null;
                }

                const parsed = parseNumber(value);
                if (!Number.isFinite(parsed)) {
                    return null;
                }

                if (parsed === 0) {
                    const digits = trimmed.replace(/[^0-9]/g, '');
                    if (digits === '') {
                        return null;
                    }
                }

                return parsed;
            }

            if (typeof value === 'bigint') {
                const converted = Number(value);
                return Number.isFinite(converted) ? converted : null;
            }

            if (value === null || typeof value === 'undefined' || typeof value === 'boolean') {
                return null;
            }

            const numeric = Number(value);
            return Number.isFinite(numeric) ? numeric : null;
        }

        function resolveCoverageSource(product) {
            if (!product || typeof product !== 'object') {
                return 'none';
            }

            const rawSource = typeof product.coverageSource === 'string' ? product.coverageSource : '';
            const normalizedSource = rawSource.toLowerCase();
            const coverageFromCobertura = toFiniteNumber(product.cobertura);
            const coverageFromStockMonths = toFiniteNumber(product.stockMonths);

            if (normalizedSource === 'estimated') {
                return 'calculated';
            }

            if (normalizedSource === 'cobertura' && coverageFromCobertura !== null) {
                return 'cobertura';
            }

            if (normalizedSource === 'stockmonths' && coverageFromStockMonths !== null) {
                return 'stockMonths';
            }

            if (normalizedSource === 'calculated') {
                return 'calculated';
            }

            if (coverageFromCobertura !== null) {
                return 'cobertura';
            }

            if (coverageFromStockMonths !== null) {
                return 'stockMonths';
            }

            if (rawSource) {
                return rawSource;
            }

            return 'none';
        }

        function getCoverageValue(product) {
            if (!product || typeof product !== 'object') {
                return null;
            }

            const source = resolveCoverageSource(product);
            switch (source) {
                case 'cobertura':
                    return toFiniteNumber(product.cobertura);
                case 'stockMonths':
                    return toFiniteNumber(product.stockMonths);
                case 'calculated': {
                    const coverageInfo = getCoverageInfo(product);
                    if (coverageInfo && Number.isFinite(coverageInfo.daysToDepletion)) {
                        return coverageInfo.daysToDepletion / 30;
                    }
                    return null;
                }
                default:
                    const coberturaValue = toFiniteNumber(product.cobertura);
                    if (coberturaValue !== null) {
                        return coberturaValue;
                    }
                    const stockMonthsValue = toFiniteNumber(product.stockMonths);
                    if (stockMonthsValue !== null) {
                        return stockMonthsValue;
                    }
                    return null;
            }
        }

        function getCoverageSourceMetadata(product) {
            const sourceKey = resolveCoverageSource(product);
            const coverageValue = getCoverageValue(product);
            const hasCoverageData = sourceKey !== 'none' && Number.isFinite(coverageValue);

            if (!hasCoverageData && sourceKey === 'none') {
                return {
                    key: 'none',
                    label: 'Sem dados',
                    detail: 'Nenhuma informa√ß√£o de cobertura dispon√≠vel.',
                    className: 'no-data'
                };
            }

            switch (sourceKey) {
                case 'stockMonths':
                    return {
                        key: 'stockMonths',
                        label: 'Dados importados',
                        detail: 'Estoque em meses fornecido no arquivo',
                        className: 'from-import'
                    };
                case 'cobertura':
                    return {
                        key: 'cobertura',
                        label: 'Dados importados',
                        detail: 'Cobertura fornecida no arquivo',
                        className: 'from-import'
                    };
                case 'calculated':
                    return {
                        key: 'calculated',
                        label: 'Estimativa autom√°tica',
                        detail: 'Proje√ß√£o baseada no consumo e no estoque atual',
                        className: 'from-estimate'
                    };
                default:
                    return {
                        key: 'none',
                        label: 'Sem dados',
                        detail: 'Nenhuma informa√ß√£o de cobertura dispon√≠vel.',
                        className: 'no-data'
                    };
            }
        }

        function escapeTooltip(text) {
            if (text === null || typeof text === 'undefined') {
                return '';
            }

            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function applyPredictionLabels() {
            const { urgentDays, warningDays } = getPredictionSettings();
            const urgentDisplay = Number.isFinite(urgentDays) ? urgentDays : '--';
            const warningDisplay = Number.isFinite(warningDays) ? warningDays : '--';

            document.querySelectorAll('[data-urgent-days]').forEach(function(element) {
                element.textContent = urgentDisplay;
            });

            document.querySelectorAll('[data-warning-days]').forEach(function(element) {
                element.textContent = warningDisplay;
            });

            const warningStart = Number.isFinite(urgentDays) ? urgentDays + 1 : null;
            const warningStartDisplay = Number.isFinite(warningStart) && Number.isFinite(warningDays) && warningStart <= warningDays
                ? warningStart
                : (Number.isFinite(urgentDays) ? urgentDays : null);

            document.querySelectorAll('[data-warning-start]').forEach(function(element) {
                element.textContent = Number.isFinite(warningStartDisplay) ? warningStartDisplay : '--';
            });

            const criticalThresholdLabel = formatCoverageThresholdLabel(coverageSegmentThresholds.critical);
            const slowThresholdLabel = formatCoverageThresholdLabel(coverageSegmentThresholds.lowUpper);

            document.querySelectorAll('[data-coverage-threshold="critical"]').forEach(function(element) {
                element.textContent = criticalThresholdLabel;
            });

            document.querySelectorAll('[data-coverage-range="low-start"]').forEach(function(element) {
                element.textContent = criticalThresholdLabel;
            });

            document.querySelectorAll('[data-coverage-range="low-end"]').forEach(function(element) {
                element.textContent = slowThresholdLabel;
            });

            document.querySelectorAll('[data-coverage-threshold="slow"]').forEach(function(element) {
                element.textContent = slowThresholdLabel;
            });
        }

        // Detectar suporte ao File System Access API
        function detectBrowserCapabilities() {
            debugLog('Iniciando detec√ß√£o de capacidades do navegador');
            
            try {
                const isFileProtocol = location.protocol === 'file:';
                const isHttps = location.protocol === 'https:';
                const isLocalhost = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
                
                debugLog(`Protocolo atual: ${location.protocol}`);
                debugLog(`√â file://: ${isFileProtocol}`);
                debugLog(`√â HTTPS: ${isHttps}`);
                debugLog(`√â localhost: ${isLocalhost}`);
                
                const hasAPI = 'showDirectoryPicker' in window;
                debugLog(`showDirectoryPicker dispon√≠vel: ${hasAPI}`);
                
                const userAgent = navigator.userAgent;
                const isChrome = userAgent.includes('Chrome') && !userAgent.includes('Edg');
                const isEdge = userAgent.includes('Edg');
                debugLog(`Navegador detectado - Chrome: ${isChrome}, Edge: ${isEdge}`);
                
                const isSecureContext = !isFileProtocol && (isHttps || isLocalhost);
                fileSystemSupported = hasAPI && isSecureContext && (isChrome || isEdge);
                debugLog(`File System API suportado: ${fileSystemSupported}`);
                
                const indicator = document.getElementById('browserModeIndicator');
                
                if (!indicator) {
                    debugLog('Elemento browserModeIndicator n√£o encontrado', 'warn');
                    return;
                }
                
                if (isFileProtocol) {
                    indicator.innerHTML = `
                        <div style="text-align: left;">
                            üîç <strong>Modo Arquivo Local</strong> - Salvamento autom√°tico n√£o dispon√≠vel<br>
                            üí° <strong>Para ativar salvamento autom√°tico:</strong><br>
                            ‚Ä¢ Use um servidor web local (Live Server, http-server, etc.)<br>
                            ‚Ä¢ Ou acesse via https://seu-site.com<br>
                            ‚Ä¢ Use o bot√£o "üíæ Baixar data.js" para salvar manualmente
                        </div>
                    `;
                    indicator.style.background = '#e7f3ff';
                    indicator.style.color = '#0066cc';
                    indicator.style.padding = '12px';
                    indicator.style.borderLeft = '4px solid #0066cc';
                    debugLog('Modo file:// detectado - salvamento autom√°tico desabilitado');
                    
                } else if (fileSystemSupported) {
                    indicator.innerHTML = '‚ú® Salvamento autom√°tico dispon√≠vel! (Chrome/Edge + Servidor Web)';
                    indicator.style.background = '#d4edda';
                    indicator.style.color = '#155724';
                    
                    setTimeout(function() {
                        const autoSaveBtn = document.getElementById('autoSaveBtn');
                        const testBtn = document.getElementById('testBtn');
                        
                        if (autoSaveBtn) {
                            autoSaveBtn.style.display = 'inline-block';
                            autoSaveBtn.classList.add('ready');
                            debugLog('Bot√£o autoSave mostrado');
                        }
                        
                        if (testBtn) {
                            testBtn.style.display = 'inline-block';
                        }
                    }, 300);
                } else {
                    let reason = '';
                    let solution = '';
                    
                    if (!hasAPI) {
                        reason = 'API n√£o suportada neste navegador';
                        solution = 'Use Chrome ou Edge atualizado';
                    } else if (!isSecureContext) {
                        reason = 'Requer conex√£o segura (HTTPS ou localhost)';
                        solution = 'Use um servidor web local ou HTTPS';
                    } else if (!isChrome && !isEdge) {
                        reason = 'Navegador n√£o suportado';
                        solution = 'Use Chrome ou Edge';
                    }
                    
                    indicator.innerHTML = `
                        <div style="text-align: left;">
                            ‚ö†Ô∏è <strong>Salvamento autom√°tico n√£o dispon√≠vel</strong><br>
                            üîç <strong>Motivo:</strong> ${reason}<br>
                            üí° <strong>Solu√ß√£o:</strong> ${solution}<br>
                            üî• Use o bot√£o "üíæ Baixar data.js" para salvar manualmente
                        </div>
                    `;
                    indicator.style.background = '#fff3cd';
                    indicator.style.color = '#856404';
                    indicator.style.padding = '12px';
                    indicator.style.borderLeft = '4px solid #ffc107';
                    debugLog(`Salvamento autom√°tico n√£o dispon√≠vel: ${reason}`);
                }
            } catch (error) {
                debugLog(`Erro na detec√ß√£o de capacidades: ${error.message}`, 'error');
                fileSystemSupported = false;
            }
        }

        // Fun√ß√£o principal para configurar pasta
        function tryAutoSave() {
            debugLog('=== TENTATIVA DE CONFIGURA√á√ÉO DE PASTA ===');
            
            if (location.protocol === 'file:') {
                const msg = `
                    ‚ö†Ô∏è Salvamento autom√°tico n√£o funciona com arquivos locais (file://)
                    
                    üí° Para ativar esta funcionalidade:
                    ‚Ä¢ Use um servidor web local (Live Server, Python, etc.)
                    ‚Ä¢ Acesse via http://localhost ou https://
                    
                    üî• Por enquanto, use "üíæ Baixar data.js" para salvar manualmente
                `;
                showMessage(msg, 'warning');
                debugLog('Tentativa de uso em protocolo file:// - n√£o suportado', 'warn');
                
                const downloadBtn = document.querySelector('button[onclick="downloadDataFile()"]');
                if (downloadBtn) {
                    downloadBtn.style.animation = 'pulse 2s infinite';
                    setTimeout(() => {
                        downloadBtn.style.animation = '';
                    }, 5000);
                }
                return;
            }
            
            if (!fileSystemSupported) {
                const msg = '‚ùå Salvamento autom√°tico n√£o suportado neste navegador/ambiente.';
                showMessage(msg, 'error');
                debugLog(msg, 'error');
                return;
            }

            if (allProductsData.length === 0) {
                const msg = '‚ö†Ô∏è Nenhum dado para salvar. Importe uma planilha primeiro.';
                showMessage(msg, 'warning');
                debugLog(msg, 'warn');
                return;
            }

            debugLog('Solicitando sele√ß√£o de pasta ao usu√°rio');
            
            window.showDirectoryPicker({
                mode: 'readwrite',
                startIn: 'documents'
            }).then(function(handle) {
                debugLog('Pasta selecionada com sucesso');
                directoryHandle = handle;
                
                showMessage('‚úÖ Pasta configurada! Salvando arquivo...', 'success');
                updateUI();
                
                return saveDataAutomatically();
                
            }).then(function(success) {
                if (success) {
                    showMessage('‚ú® Arquivo data.js salvo automaticamente na pasta selecionada!', 'success');
                    debugLog('Salvamento autom√°tico conclu√≠do com sucesso');
                } else {
                    showMessage('‚ùå Erro ao salvar o arquivo. Verifique as permiss√µes.', 'error');
                    debugLog('Falha no salvamento autom√°tico', 'error');
                }
            }).catch(function(error) {
                if (error.name === 'AbortError') {
                    debugLog('Usu√°rio cancelou a sele√ß√£o de pasta');
                    showMessage('‚ùå Sele√ß√£o de pasta cancelada pelo usu√°rio.', 'info');
                } else {
                    debugLog(`Erro no processo: ${error.message}`, 'error');
                    showMessage(`‚ùå Erro: ${error.message}`, 'error');
                }
            });
        }

        function reconfigureAutoSave() {
            debugLog('Reconfigurando pasta para salvamento autom√°tico');
            directoryHandle = null;
            tryAutoSave();
        }

        function saveDataAutomatically() {
            return new Promise(function(resolve, reject) {
                debugLog('=== INICIANDO SALVAMENTO AUTOM√ÅTICO ===');
                
                if (!directoryHandle) {
                    debugLog('directoryHandle n√£o configurado', 'error');
                    resolve(false);
                    return;
                }
                
                if (allProductsData.length === 0) {
                    debugLog('Nenhum dado para salvar', 'error');
                    resolve(false);
                    return;
                }

                try {
                    debugLog('Gerando conte√∫do do arquivo data.js');
                    const dataContent = saveDataToFile(allProductsData);
                    debugLog(`Conte√∫do gerado: ${dataContent.length} caracteres`);
                    
                    debugLog('Verificando permiss√µes de escrita');
                    directoryHandle.requestPermission({ mode: 'readwrite' }).then(function(permission) {
                        debugLog(`Permiss√£o obtida: ${permission}`);
                        
                        if (permission !== 'granted') {
                            throw new Error('Permiss√£o de escrita negada');
                        }
                        
                        debugLog('Criando/obtendo arquivo data.js');
                        return directoryHandle.getFileHandle('data.js', { create: true });
                        
                    }).then(function(fileHandle) {
                        debugLog('Arquivo obtido, criando stream de escrita');
                        return fileHandle.createWritable();
                        
                    }).then(function(writable) {
                        debugLog('Escrevendo conte√∫do no arquivo');
                        return writable.write(dataContent).then(function() {
                            debugLog('Fechando arquivo');
                            return writable.close();
                        });
                        
                    }).then(function() {
                        debugLog('Arquivo salvo com sucesso!');
                        
                        localStorage.setItem('stockDataTimestamp', Date.now().toString());
                        updateUI();
                        
                        resolve(true);
                        
                    }).catch(function(error) {
                        debugLog(`Erro no salvamento: ${error.message}`, 'error');
                        reject(error);
                    });
                    
                } catch (error) {
                    debugLog(`Erro na gera√ß√£o do conte√∫do: ${error.message}`, 'error');
                    reject(error);
                }
            });
        }

        function testAutoSave() {
            debugLog('=== TESTE DE SALVAMENTO ===');
            
            if (!fileSystemSupported) {
                showMessage('‚ùå Salvamento autom√°tico n√£o suportado neste navegador.', 'error');
                return;
            }
            
            if (!directoryHandle) {
                showMessage('‚ö†Ô∏è Configure uma pasta primeiro clicando em "Configurar Pasta".', 'warning');
                return;
            }
            
            if (allProductsData.length === 0) {
                showMessage('‚ö†Ô∏è Nenhum dado para testar. Importe uma planilha primeiro.', 'warning');
                return;
            }
            
            saveDataAutomatically().then(function(success) {
                if (success) {
                    showMessage('‚úÖ Teste realizado! Arquivo salvo com sucesso.', 'success');
                } else {
                    showMessage('‚ùå Falha no teste de salvamento.', 'error');
                }
            }).catch(function(error) {
                showMessage(`‚ùå Erro no teste: ${error.message}`, 'error');
            });
        }

        function updateUI() {
            debugLog('Atualizando interface do usu√°rio');
            
            try {
                const lastUpdateDiv = document.getElementById('lastUpdateInfo');
                if (!lastUpdateDiv) {
                    debugLog('Elemento lastUpdateInfo n√£o encontrado', 'warn');
                    return;
                }
                
                let infoText = '';
                
                if (typeof window.stockMetadata !== 'undefined' && window.stockMetadata.lastUpdate) {
                    const date = new Date(window.stockMetadata.lastUpdate);
                    const formattedDate = date.toLocaleString('pt-BR');
                    infoText = `üìÖ √öltima atualiza√ß√£o: ${formattedDate}`;
                } else {
                    const storedData = localStorage.getItem('stockDataTimestamp');
                    if (storedData) {
                        const date = new Date(parseInt(storedData));
                        const formattedDate = date.toLocaleString('pt-BR');
                        infoText = `üìÖ √öltima atualiza√ß√£o: ${formattedDate}`;
                    } else {
                        infoText = 'üìÖ Nenhuma importa√ß√£o realizada ainda';
                    }
                }
                
                if (fileSystemSupported && directoryHandle) {
                    const autoSaveBtn = document.getElementById('autoSaveBtn');
                    const reconfigBtn = document.getElementById('reconfigBtn');
                    const testBtn = document.getElementById('testBtn');
                    
                    if (autoSaveBtn) {
                        autoSaveBtn.textContent = '‚ú® Salvar na Pasta';
                        autoSaveBtn.classList.remove('ready');
                    }
                    if (reconfigBtn) reconfigBtn.style.display = 'inline-block';
                    if (testBtn) testBtn.style.display = 'inline-block';
                    
                    infoText += '<br>üóÇÔ∏è <span style="color: #28a745; font-weight: bold;">Pasta configurada - salvamento autom√°tico ativo!</span>';
                } else if (fileSystemSupported) {
                    infoText += '<br>‚öôÔ∏è <span style="color: #1F448C;">Clique em "Configurar Pasta" para ativar salvamento autom√°tico</span>';
                }
                
                lastUpdateDiv.innerHTML = infoText;
                debugLog('Interface atualizada com sucesso');
                
            } catch (error) {
                debugLog(`Erro ao atualizar interface: ${error.message}`, 'error');
            }
        }

        // Carregar dados ao inicializar
        function loadData() {
            debugLog('=== CARREGANDO DADOS ===');
            
            if (typeof window.stockData !== 'undefined' && Array.isArray(window.stockData) && window.stockData.length > 0) {
                allProductsData = window.stockData.map(function(product) {
                    return ensureProductHistoryStructure(product);
                });
                debugLog(`Dados carregados do data.js: ${allProductsData.length} produtos`);
                showMessage(`‚úÖ ${allProductsData.length} produtos carregados do data.js`, 'success');
                if (typeof window.stockMetadata === 'object' && window.stockMetadata !== null) {
                    activeImportDescriptor = window.stockMetadata.source || 'data.js';
                    lastImportedFileName = window.stockMetadata.sourceFile || 'data.js';
                    lastImportedSheetName = window.stockMetadata.sheetName || '';
                } else {
                    activeImportDescriptor = 'data.js';
                    lastImportedFileName = 'data.js';
                    lastImportedSheetName = '';
                }
            } else {
                const storedData = localStorage.getItem('stockData');
                if (storedData) {
                    try {
                        const parsedData = JSON.parse(storedData);
                        allProductsData = Array.isArray(parsedData)
                            ? parsedData.map(function(product) {
                                return ensureProductHistoryStructure(product);
                            })
                            : [];
                        debugLog(`Dados carregados do localStorage: ${allProductsData.length} produtos`);
                        showMessage(`‚úÖ ${allProductsData.length} produtos carregados do backup local`, 'info');
                        activeImportDescriptor = 'backup local';
                        lastImportedFileName = 'localStorage';
                        lastImportedSheetName = '';
                    } catch (e) {
                        debugLog(`Erro ao parsear dados do localStorage: ${e.message}`, 'error');
                        allProductsData = [];
                    }
                } else {
                    allProductsData = [];
                    debugLog('Nenhum dado encontrado');
                    activeImportDescriptor = 'dados carregados';
                    lastImportedFileName = '';
                    lastImportedSheetName = '';
                }
            }

            if (allProductsData.length === 0) {
                showMessage('‚ö†Ô∏è Nenhum dado encontrado. Importe uma planilha para come√ßar.', 'info');
            }

            initializeDashboard();
        }

        function initializeDashboard() {
            debugLog('Inicializando dashboard');
            
            try {
                populateFamilyFilter();
                populateSupplierFilter();
                showAllProducts();
                updatePredictiveAnalysis();
                updateUI();
                
                debugLog('Dashboard inicializado com sucesso');
            } catch (error) {
                debugLog(`Erro ao inicializar dashboard: ${error.message}`, 'error');
                showMessage('‚ö†Ô∏è Dashboard carregado com problemas. Use o diagn√≥stico para mais detalhes.', 'warning');
            }
        }

        function saveDataToFile(data) {
            try {
                debugLog('Gerando arquivo data.js');

                const processedData = data.map(function(product) {
                    const monthlyValues = sortMonthlyValues(cloneMonthlyValues(product.monthlyValues));
                    const historyEntries = Array.isArray(product.importHistory)
                        ? product.importHistory.map(function(entry) {
                            const normalizedEntry = normalizeHistoryEntry(entry);
                            return {
                                sheetName: normalizedEntry.sheetName,
                                months: normalizedEntry.months,
                                totals: normalizedEntry.totals
                            };
                        })
                        : [];

                    return {
                        code: product.code || '',
                        supplier: product.supplier || '',
                        family: product.family || '',
                        item: product.item || '',
                        stock14: product.stock14 || 0,
                        stock9013: product.stock9013 || 0,
                        stock9015: product.stock9015 || 0,
                        stockMonths: product.stockMonths || 0,
                        vendas4M: product.vendas4M || 0,
                        media3M: product.media3M || 0,
                        novembro: product.novembro || 0,
                        dezembro: product.dezembro || 0,
                        cobertura: Number.isFinite(product.cobertura)
                            ? product.cobertura
                            : (Number.isFinite(product.stockMonths) ? product.stockMonths : 0),
                        monthlyValues: monthlyValues,
                        importHistory: historyEntries
                    };
                });

                const dataContent = `// Dados do Dashboard de Estoque v1.3 - Gerado em ${new Date().toLocaleString('pt-BR')}
// Substitua este arquivo na pasta compartilhada para atualizar os dados
console.log('Carregando data.js v1.3...');

window.stockData = ${JSON.stringify(processedData, null, 2)};

// Metadados
window.stockMetadata = {
    lastUpdate: "${new Date().toISOString()}",
    totalProducts: ${processedData.length},
    generatedBy: "Dashboard de Estoque v1.3 - Importador com m√∫ltiplas abas",
    version: "1.3.0",
    sourceFile: "${lastImportedFileName || ''}",
    sheetName: "${lastImportedSheetName || ''}",
    source: "${activeImportDescriptor || ''}"
};

console.log('data.js v1.3 carregado com', window.stockData.length, 'produtos');`;
                
                debugLog(`Arquivo gerado: ${dataContent.length} caracteres`);
                return dataContent;
            } catch (error) {
                debugLog(`Erro ao gerar arquivo: ${error.message}`, 'error');
                throw error;
            }
        }

        function extractWorkbookData(workbook, sheetName) {
            if (!workbook || !sheetName) {
                throw new Error('Dados da planilha indispon√≠veis para processamento.');
            }

            const sheet = workbook.Sheets[sheetName];
            if (!sheet) {
                throw new Error(`Aba "${sheetName}" n√£o encontrada.`);
            }

            const sheetRows = XLSX.utils.sheet_to_json(sheet, { header: 1, raw: false, defval: '' });
            if (!Array.isArray(sheetRows) || sheetRows.length === 0) {
                return [];
            }

            const headers = sheetRows[0].map(function(headerCell) {
                return headerCell === null || typeof headerCell === 'undefined'
                    ? ''
                    : headerCell.toString();
            });

            const rows = sheetRows.slice(1);
            return processExcelRows(headers, rows, sheetName);
        }

        function completeImport(data, sourceInfo) {
            if (!Array.isArray(data) || data.length === 0) {
                throw new Error('Nenhum produto v√°lido encontrado na planilha');
            }

            allProductsData = data.map(function(product) {
                return ensureProductHistoryStructure(product);
            });
            debugLog(`Dados importados: ${data.length} produtos`);

            localStorage.setItem('stockData', JSON.stringify(allProductsData));
            localStorage.setItem('stockDataTimestamp', Date.now().toString());

            const descriptor = sourceInfo && sourceInfo.label ? sourceInfo.label : 'dados importados';
            activeImportDescriptor = descriptor;
            lastImportedFileName = sourceInfo && sourceInfo.fileName ? sourceInfo.fileName : '';
            lastImportedSheetName = sourceInfo && sourceInfo.sheetName ? sourceInfo.sheetName : '';

            const sheetSummary = sourceInfo && sourceInfo.sheetName
                ? ` Abas: ${sourceInfo.sheetName}.`
                : '';
            showMessage(`‚úÖ Dados importados com sucesso! ${data.length} produtos carregados.${sheetSummary}`, 'success');

            if (fileSystemSupported && directoryHandle) {
                debugLog('Tentando salvamento autom√°tico ap√≥s importa√ß√£o');
                saveDataAutomatically().then(function(success) {
                    if (success) {
                        showMessage('‚ú® Arquivo data.js atualizado automaticamente!', 'success');
                    }
                }).catch(function(error) {
                    debugLog(`Erro no salvamento autom√°tico: ${error.message}`, 'error');
                    showMessage('‚ö†Ô∏è Dados importados, mas erro no salvamento autom√°tico. Use "üíæ Baixar data.js".', 'warning');
                });
            } else if (fileSystemSupported) {
                showMessage('üí° Dica: Clique em "Configurar Pasta" para ativar salvamento autom√°tico!', 'info');
            }

            initializeDashboard();
        }

        function importData() {
            const file = document.getElementById('excelFile').files[0];
            if (!file) {
                showMessage('‚ùå Por favor, selecione um arquivo primeiro.', 'error');
                return;
            }

            debugLog(`Importando arquivo: ${file.name} (${file.size} bytes)`);

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const fileName = file.name.toLowerCase();

                    if (fileName.endsWith('.csv')) {
                        const rawProducts = processCSV(e.target.result);
                        const finalizedProducts = finalizeProductList(rawProducts, 'Arquivo CSV');
                        completeImport(finalizedProducts, {
                            label: file.name,
                            fileName: file.name,
                            sheetName: 'Arquivo CSV'
                        });
                    } else if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
                        const workbook = XLSX.read(e.target.result, { type: 'array' });
                        const sheetNames = workbook.SheetNames || [];

                        if (sheetNames.length === 0) {
                            throw new Error('A planilha n√£o cont√©m abas dispon√≠veis.');
                        }

                        const { combinedData, processedSheets } = mergeWorkbookData(workbook, sheetNames);

                        if (processedSheets.length === 0 || combinedData.length === 0) {
                            throw new Error('Nenhum dado v√°lido encontrado nas abas da planilha.');
                        }

                        const label = processedSheets.length === 1
                            ? `${file.name} ¬∑ ${processedSheets[0].name}`
                            : `${file.name} ¬∑ ${processedSheets.length} abas`;
                        const sheetSummary = processedSheets.map(function(info) {
                            return `${info.name} (${info.count})`;
                        }).join(', ');

                        completeImport(combinedData, {
                            label,
                            fileName: file.name,
                            sheetName: sheetSummary
                        });
                    } else {
                        throw new Error('Formato de arquivo n√£o suportado');
                    }
                } catch (error) {
                    debugLog(`Erro ao processar arquivo: ${error.message}`, 'error');
                    showMessage(`‚ùå Erro ao processar arquivo: ${error.message}`, 'error');
                }
            };

            if (file.name.toLowerCase().endsWith('.csv')) {
                reader.readAsText(file);
            } else {
                reader.readAsArrayBuffer(file);
            }
        }

        function openTemplateGenerator() {
            try {
                window.open('gerador_template.html', '_blank');
            } catch (error) {
                debugLog(`Erro ao abrir gerador de template: ${error.message}`, 'error');
                showMessage('‚ùå Erro ao abrir gerador de template', 'error');
            }
        }

        function runDiagnostic() {
            debugLog('=== EXECUTANDO DIAGN√ìSTICO COMPLETO ===');
            console.clear();
            
            const report = [];
            report.push('üîç DIAGN√ìSTICO COMPLETO DO DASHBOARD v1.3');
            report.push('==========================================');
            
            // 1. Verificar dados
            report.push('\nüìä DADOS:');
            report.push(`- window.stockData existe: ${typeof window.stockData !== 'undefined'}`);
            report.push(`- √â array: ${Array.isArray(window.stockData)}`);
            report.push(`- Quantidade: ${window.stockData ? window.stockData.length : 0}`);
            report.push(`- allProductsData: ${allProductsData ? allProductsData.length : 'undefined'}`);
            
            // 2. Verificar elementos DOM
            report.push('\nüéØ ELEMENTOS DOM:');
            const elementos = ['importContent', 'toggleIcon', 'browserModeIndicator', 'autoSaveBtn', 'testBtn', 'lastUpdateInfo', 'excelFile', 'mappingDebug'];
            elementos.forEach(function(id) {
                const el = document.getElementById(id);
                const exists = !!el;
                const visible = el ? el.offsetHeight > 0 : false;
                report.push(`- ${id}: ${exists ? '‚úÖ' : '‚ùå'} ${exists ? (visible ? '(vis√≠vel)' : '(oculto)') : ''}`);
            });
            
            // 3. Verificar capacidades do navegador
            report.push('\nüåê NAVEGADOR:');
            report.push(`- UserAgent: ${navigator.userAgent}`);
            report.push(`- Protocolo: ${location.protocol}`);
            report.push(`- Hostname: ${location.hostname}`);
            report.push(`- URL completa: ${location.href}`);
            report.push(`- showDirectoryPicker: ${'showDirectoryPicker' in window ? '‚úÖ' : '‚ùå'}`);
            report.push(`- fileSystemSupported: ${fileSystemSupported ? '‚úÖ' : '‚ùå'}`);
            report.push(`- directoryHandle: ${directoryHandle ? '‚úÖ Configurado' : '‚ùå N√£o configurado'}`);
            
            // 4. Verificar localStorage
            report.push('\nüíæ ARMAZENAMENTO LOCAL:');
            const storedData = localStorage.getItem('stockData');
            const storedTimestamp = localStorage.getItem('stockDataTimestamp');
            report.push(`- Dados salvos: ${storedData ? 'Sim' : 'N√£o'}`);
            report.push(`- Timestamp: ${storedTimestamp ? new Date(parseInt(storedTimestamp)).toLocaleString('pt-BR') : 'N√£o'}`);
            
            // 5. Verificar mapeamento (novo)
            report.push('\nüìã MAPEAMENTO:');
            if (lastMappingInfo) {
                report.push('- √öltimo mapeamento executado: ‚úÖ');
                report.push(`- Colunas detectadas: ${lastMappingInfo.headers.length}`);
                report.push(`- Avisos de mapeamento: ${lastMappingInfo.warnings.length}`);
                if (lastMappingInfo.warnings.length > 0) {
                    lastMappingInfo.warnings.forEach(warning => {
                        report.push(`  ‚ö†Ô∏è ${warning}`);
                    });
                }
            } else {
                report.push('- Nenhum mapeamento executado ainda');
            }
            
            // 6. Verificar funcionalidades
            report.push('\n‚öôÔ∏è FUNCIONALIDADES:');
            report.push(`- Import section expanded: ${document.getElementById('importContent')?.classList.contains('expanded') ? 'Sim' : 'N√£o'}`);
            report.push(`- Debug mode: ${debugMode ? 'Ativo' : 'Inativo'}`);
            report.push(`- Mapping debug mode: ${mappingDebugMode ? 'Ativo' : 'Inativo'}`);
            
            if (location.protocol === 'file:') {
                report.push('\nüöÄ INSTRU√á√ïES PARA SALVAMENTO AUTOM√ÅTICO:');
                report.push('Voc√™ est√° usando protocolo file://, que n√£o suporta File System API.');
                report.push('Para ativar salvamento autom√°tico, use um servidor web local:');
                report.push('');
                report.push('M√âTODO 1 - Python (j√° instalado no Windows):');
                report.push('1. Abra o Prompt de Comando na pasta do projeto');
                report.push('2. Execute: python -m http.server 8000');
                report.push('3. Acesse: http://localhost:8000');
                report.push('');
                report.push('M√âTODO 2 - Live Server (VS Code):');
                report.push('1. Instale a extens√£o "Live Server" no VS Code');
                report.push('2. Clique direito no index.html ‚Üí "Open with Live Server"');
                report.push('3. Acesse: http://localhost:5500');
            }
            
            report.push('\nüéØ DIAGN√ìSTICO CONCLU√çDO!');
            
            // Mostrar relat√≥rio
            const fullReport = report.join('\n');
            console.log(fullReport);
            
            if (debugMode) {
                const debugDiv = document.getElementById('debugInfo');
                if (debugDiv) {
                    debugDiv.innerHTML = '<pre>' + fullReport + '</pre>';
                }
            }
            
            showMessage('üîç Diagn√≥stico executado! Verifique o console (F12) para detalhes completos.', 'info');
        }

        function toggleImportSection() {
            const content = document.getElementById('importContent');
            const icon = document.getElementById('toggleIcon');
            
            if (!content || !icon) {
                debugLog('Elementos de importa√ß√£o n√£o encontrados', 'error');
                return;
            }
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                icon.classList.remove('expanded');
                icon.textContent = '‚ñº';
                debugLog('Se√ß√£o de importa√ß√£o fechada');
            } else {
                content.classList.add('expanded');
                icon.classList.add('expanded');  
                icon.textContent = '‚ñ≤';
                debugLog('Se√ß√£o de importa√ß√£o aberta');
            }
        }

        function downloadDataFile() {
            if (allProductsData.length === 0) {
                showMessage('‚ùå Nenhum dado para salvar. Importe uma planilha primeiro.', 'error');
                return;
            }

            const dataContent = saveDataToFile(allProductsData);
            const blob = new Blob([dataContent], { type: 'text/javascript' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'data.js';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showMessage('üíæ Arquivo data.js baixado! Substitua o arquivo na pasta compartilhada.', 'success');
            debugLog('Arquivo data.js baixado via download manual');
        }

        function showMessage(message, type) {
            const messagesDiv = document.getElementById('importMessages');
            const messageClass = {
                'success': 'success-message',
                'error': 'error-message',
                'warning': 'warning-message',
                'info': 'info-message'
            }[type] || 'info-message';
            
            messagesDiv.innerHTML = `<div class="${messageClass}">${message}</div>`;
            
            setTimeout(function() {
                messagesDiv.innerHTML = '';
            }, 8000);
        }

        // === FUN√á√ïES DE BUSCA E FILTROS ===
        function updateSearchSelectionDisplay() {
            const container = document.getElementById('searchSelection');
            if (!container) {
                return;
            }

            if (!selectedSearchProduct) {
                container.innerHTML = '';
                container.classList.remove('is-visible');
                return;
            }

            const product = selectedSearchProduct;
            const productName = product && product.item && product.item.toString().trim() !== ''
                ? product.item
                : (product && product.code) ? product.code : 'Produto';
            const metaParts = [];
            if (product && product.code) {
                metaParts.push(`C√≥digo ${product.code}`);
            }
            if (product && product.family) {
                metaParts.push(product.family);
            }
            if (product && product.supplier) {
                metaParts.push(product.supplier);
            }
            const metaHtml = metaParts.length > 0
                ? `<span class="selection-meta">${escapeTooltip(metaParts.join(' ‚Ä¢ '))}</span>`
                : '';
            const actions = [];
            if (product && product.code) {
                const safeCode = escapeTooltip(product.code);
                actions.push(`<button type="button" class="selection-action" data-code="${safeCode}" onclick="openProductHistoryFromElement(this)">Abrir hist√≥rico</button>`);
            }
            actions.push('<button type="button" class="selection-action selection-action-secondary" onclick="clearSearchSelection()">Limpar</button>');
            const actionsHtml = `<div class="selection-actions">${actions.join('')}</div>`;

            container.innerHTML = `
                <div class="search-selection-card">
                    <span class="selection-badge">Produto selecionado</span>
                    <div class="selection-content">
                        <strong>${escapeTooltip(productName)}</strong>
                        ${metaHtml}
                    </div>
                    ${actionsHtml}
                </div>`;
            container.classList.add('is-visible');
        }

        function resetSearchSelection() {
            selectedSearchProduct = null;
            updateSearchSelectionDisplay();
        }

        function clearSearchSelection() {
            resetSearchSelection();
            applyAllFilters();
        }

        function formatAssistantFocusLabel(context) {
            if (!context) {
                return '';
            }

            const focusTokens = Array.isArray(context.focusTokens)
                ? context.focusTokens.filter(Boolean)
                : [];

            if (focusTokens.length > 0) {
                return focusTokens.map(function(token) {
                    if (!token) {
                        return '';
                    }
                    if (token.length <= 2) {
                        return token.toUpperCase();
                    }
                    return token.charAt(0).toUpperCase() + token.slice(1);
                }).join(' / ');
            }

            if (context.highlightTerm && context.highlightTerm.trim() !== '') {
                return context.highlightTerm.trim();
            }

            if (context.rawQuery && context.rawQuery.trim() !== '') {
                return context.rawQuery.trim();
            }

            return '';
        }

        function getAssistantRelevantProducts(context, productMatches) {
            const focusTokens = context && Array.isArray(context.focusTokens)
                ? context.focusTokens.filter(Boolean)
                : [];
            const normalizedFocus = focusTokens.map(function(token) {
                return token.toString().toLowerCase();
            });

            let candidates = Array.isArray(productMatches) && productMatches.length > 0
                ? productMatches.slice()
                : filteredData.slice(0, 20);

            if (normalizedFocus.length > 0) {
                const matchesFocus = function(product) {
                    if (!product) {
                        return false;
                    }
                    const haystack = [
                        (product.item || ''),
                        (product.code || ''),
                        (product.family || ''),
                        (product.supplier || '')
                    ].join(' ').toLowerCase();

                    return normalizedFocus.every(function(token) {
                        return token && haystack.includes(token);
                    });
                };

                let filteredCandidates = candidates.filter(matchesFocus);

                if (filteredCandidates.length === 0) {
                    filteredCandidates = filteredData.filter(matchesFocus);
                }

                candidates = filteredCandidates;
            }

            if (!Array.isArray(candidates) || candidates.length === 0) {
                return [];
            }

            return candidates.slice(0, 20);
        }

        function buildAssistantPanel(context, productMatches, filteredCount, conversationMatch) {
            if (!context || !context.intent || context.intent === 'search') {
                return null;
            }

            const focusLabel = formatAssistantFocusLabel(context);
            const relevantProducts = getAssistantRelevantProducts(context, productMatches);
            const messages = [];
            const insights = conversationMatch || (window.conversationParameters && typeof window.conversationParameters.resolve === 'function'
                ? window.conversationParameters.resolve(context)
                : null);
            const expectsExact = Boolean(insights && insights.expectExact);
            let hasExactAnswer = false;

            if (context.intent === 'ask_supplier') {
                const supplierMap = new Map();

                relevantProducts.forEach(function(product) {
                    if (!product || !product.supplier) {
                        return;
                    }
                    const supplierName = (product.supplier || '').toString().trim();
                    if (!supplierName) {
                        return;
                    }

                    if (!supplierMap.has(supplierName)) {
                        supplierMap.set(supplierName, {
                            count: 0,
                            families: new Set()
                        });
                    }

                    const entry = supplierMap.get(supplierName);
                    entry.count += 1;
                    if (product.family) {
                        entry.families.add(product.family);
                    }
                });

                if (supplierMap.size > 0) {
                    const supplierEntries = Array.from(supplierMap.entries()).sort(function(a, b) {
                        if (b[1].count !== a[1].count) {
                            return b[1].count - a[1].count;
                        }
                        return a[0].localeCompare(b[0], 'pt-BR', { sensitivity: 'base' });
                    });

                    const supplierCount = supplierEntries.length;
                    const relationshipLabel = supplierCount === 1
                        ? 'Encontrei 1 fornecedor'
                        : `Encontrei ${supplierCount} fornecedores`;
                    const scopeText = focusLabel
                        ? ` relacionado${supplierCount > 1 ? 's' : ''} a <strong>${escapeTooltip(focusLabel)}</strong>`
                        : '';
                    const helperText = `${relationshipLabel}${scopeText}. Escolha um para aplicar o filtro automaticamente.`;

                    const chipHtml = supplierEntries.slice(0, 6).map(function(entry) {
                        const supplierName = entry[0];
                        const supplierStats = entry[1];
                        const countLabel = supplierStats.count === 1
                            ? '1 item'
                            : `${supplierStats.count} itens`;
                        return `<button type="button" class="assistant-action-chip" data-suggestion-type="supplier" data-supplier="${escapeTooltip(supplierName)}">`
                            + `<span class="chip-label">${escapeTooltip(supplierName)}</span>`
                            + `<span class="chip-count">${escapeTooltip(countLabel)}</span>`
                            + `</button>`;
                    }).join('');

                    const extraSuppliers = supplierEntries.length - Math.min(6, supplierEntries.length);
                    const extraNote = extraSuppliers > 0
                        ? `<span class="assistant-note">+${extraSuppliers} fornecedor${extraSuppliers > 1 ? 'es' : ''} adicionais nos resultados.</span>`
                        : '';

                    messages.push(`
                        <div class="assistant-message">
                            <div class="assistant-avatar" aria-hidden="true">üîé</div>
                            <div class="assistant-content">
                                <div class="assistant-text">${helperText}</div>
                                <div class="assistant-actions">${chipHtml}</div>
                                ${extraNote}
                            </div>
                        </div>
                    `);

                    if (expectsExact && supplierEntries.length === 1) {
                        hasExactAnswer = true;
                    }
                } else {
                    const fallbackText = focusLabel
                        ? `N√£o encontrei fornecedores vinculados a <strong>${escapeTooltip(focusLabel)}</strong>. Tente especificar o c√≥digo ou parte do nome do produto.`
                        : 'Me conta qual produto, c√≥digo ou fam√≠lia voc√™ quer e eu localizo o fornecedor para voc√™.';

                    messages.push(`
                        <div class="assistant-message">
                            <div class="assistant-avatar" aria-hidden="true">üîé</div>
                            <div class="assistant-content">
                                <div class="assistant-text">${fallbackText}</div>
                            </div>
                        </div>
                    `);
                }
            } else if (context.intent === 'ask_history') {
                const targetProduct = Array.isArray(productMatches) && productMatches.length > 0
                    ? productMatches[0]
                    : (filteredData.length > 0 ? filteredData[0] : null);

                if (targetProduct && targetProduct.code) {
                    const productLabel = (targetProduct.item && targetProduct.item.trim() !== '')
                        ? targetProduct.item
                        : targetProduct.code;
                    const metaPieces = [];
                    if (targetProduct.code) {
                        metaPieces.push(`C√≥digo ${targetProduct.code}`);
                    }
                    if (targetProduct.supplier) {
                        metaPieces.push(targetProduct.supplier);
                    }

                    const metaText = metaPieces.length > 0
                        ? `<span class="assistant-note">${escapeTooltip(metaPieces.join(' ‚Ä¢ '))}</span>`
                        : '';

                    messages.push(`
                        <div class="assistant-message">
                            <div class="assistant-avatar" aria-hidden="true">üìà</div>
                            <div class="assistant-content">
                                <div class="assistant-text">Encontrei <strong>${escapeTooltip(productLabel)}</strong>. Clique abaixo para abrir o hist√≥rico e ver as √∫ltimas importa√ß√µes.</div>
                                <div class="assistant-actions">
                                    <button type="button" class="assistant-action-chip" data-suggestion-type="product-history" data-product-code="${escapeTooltip(targetProduct.code)}" data-search-term="${escapeTooltip(productLabel)}">Abrir hist√≥rico</button>
                                </div>
                                ${metaText}
                            </div>
                        </div>
                    `);

                    if (expectsExact) {
                        hasExactAnswer = true;
                    }
                } else {
                    messages.push(`
                        <div class="assistant-message">
                            <div class="assistant-avatar" aria-hidden="true">üìà</div>
                            <div class="assistant-content">
                                <div class="assistant-text">Ainda n√£o consegui identificar o produto para exibir o hist√≥rico. Informe o c√≥digo ou parte do nome para continuar.</div>
                            </div>
                        </div>
                    `);
                }
            } else if (context.intent === 'ask_class') {
                const targetProduct = Array.isArray(productMatches) && productMatches.length > 0
                    ? productMatches[0]
                    : (filteredData.length > 0 ? filteredData[0] : null);

                const classDescriptions = {
                    A: 'Alta relev√¢ncia nas vendas (topo do portf√≥lio).',
                    B: 'Participa√ß√£o intermedi√°ria, exige aten√ß√£o equilibrada.',
                    C: 'Baixa representatividade, reposi√ß√£o pontual.'
                };

                if (targetProduct && targetProduct.currentAbcClass) {
                    const classKey = (targetProduct.currentAbcClass || '').toString().trim().toUpperCase();
                    const classLabel = classKey ? `Classe ${classKey}` : 'Classe ‚Äî';
                    const description = classDescriptions[classKey] || 'Classifica√ß√£o calculada pelo % Individual de vendas.';
                    const productLabel = targetProduct.item && targetProduct.item.trim() !== ''
                        ? targetProduct.item
                        : (targetProduct.code || '');
                    const metaPieces = [];
                    if (targetProduct.code) {
                        metaPieces.push(`C√≥digo ${targetProduct.code}`);
                    }
                    if (targetProduct.supplier) {
                        metaPieces.push(targetProduct.supplier);
                    }
                    const metaText = metaPieces.length > 0
                        ? `<span class="assistant-note">${escapeTooltip(metaPieces.join(' ‚Ä¢ '))}</span>`
                        : '';
                    const chipKey = `abc-${classKey.toLowerCase()}`;
                    const chipHtml = classKey
                        ? `<button type="button" class="assistant-action-chip" data-suggestion-type="abc-class" data-abc-class="${escapeTooltip(chipKey)}">`
                            + `<span class="chip-label">Filtrar ${escapeTooltip(classLabel)}</span>`
                            + `</button>`
                        : '';

                    messages.push(`
                        <div class="assistant-message">
                            <div class="assistant-avatar" aria-hidden="true">üéØ</div>
                            <div class="assistant-content">
                                <div class="assistant-text"><strong>${escapeTooltip(productLabel)}</strong> est√° na <strong>${escapeTooltip(classLabel)}</strong>. ${escapeTooltip(description)}</div>
                                <div class="assistant-actions">${chipHtml}</div>
                                ${metaText}
                            </div>
                        </div>
                    `);

                    if (expectsExact && classKey) {
                        hasExactAnswer = true;
                    }
                } else {
                    messages.push(`
                        <div class="assistant-message">
                            <div class="assistant-avatar" aria-hidden="true">üéØ</div>
                            <div class="assistant-content">
                                <div class="assistant-text">Ainda n√£o identifiquei a classe ABC do item pedido. Informe o c√≥digo ou parte do nome para eu analisar.</div>
                            </div>
                        </div>
                    `);
                }
            } else if (context.intent === 'ask_family') {
                const familyMap = new Map();
                relevantProducts.forEach(function(product) {
                    if (!product || !product.family) {
                        return;
                    }
                    const familyName = (product.family || '').toString().trim();
                    if (!familyName) {
                        return;
                    }
                    if (!familyMap.has(familyName)) {
                        familyMap.set(familyName, 0);
                    }
                    familyMap.set(familyName, familyMap.get(familyName) + 1);
                });

                if (familyMap.size > 0) {
                    const entries = Array.from(familyMap.entries()).sort(function(a, b) {
                        if (b[1] !== a[1]) {
                            return b[1] - a[1];
                        }
                        return a[0].localeCompare(b[0], 'pt-BR', { sensitivity: 'base' });
                    });
                    const totalFamilies = entries.length;
                    const scopeText = focusLabel
                        ? ` relacionados a <strong>${escapeTooltip(focusLabel)}</strong>`
                        : '';
                    const headerText = totalFamilies === 1
                        ? `Encontrei a fam√≠lia${scopeText}.`
                        : `Encontrei ${totalFamilies} fam√≠lias${scopeText}.`;
                    const chipHtml = entries.slice(0, 6).map(function(entry) {
                        const familyName = entry[0];
                        const count = entry[1];
                        const countLabel = count === 1 ? '1 item' : `${count} itens`;
                        return `<button type="button" class="assistant-action-chip" data-suggestion-type="family" data-family="${escapeTooltip(familyName)}">`
                            + `<span class="chip-label">${escapeTooltip(familyName)}</span>`
                            + `<span class="chip-count">${escapeTooltip(countLabel)}</span>`
                            + `</button>`;
                    }).join('');
                    const extraFamilies = totalFamilies - Math.min(6, totalFamilies);
                    const extraNote = extraFamilies > 0
                        ? `<span class="assistant-note">+${extraFamilies} fam√≠lia${extraFamilies > 1 ? 's' : ''} adicionais nos resultados.</span>`
                        : '';

                    messages.push(`
                        <div class="assistant-message">
                            <div class="assistant-avatar" aria-hidden="true">üóÇÔ∏è</div>
                            <div class="assistant-content">
                                <div class="assistant-text">${headerText}</div>
                                <div class="assistant-actions">${chipHtml}</div>
                                ${extraNote}
                            </div>
                        </div>
                    `);

                    if (expectsExact && totalFamilies === 1) {
                        hasExactAnswer = true;
                    }
                } else {
                    messages.push(`
                        <div class="assistant-message">
                            <div class="assistant-avatar" aria-hidden="true">üóÇÔ∏è</div>
                            <div class="assistant-content">
                                <div class="assistant-text">N√£o consegui identificar a fam√≠lia desejada. Informe o produto ou c√≥digo para que eu encontre o agrupamento correto.</div>
                            </div>
                        </div>
                    `);
                }
            } else if (context.intent === 'ask_stock') {
                if (filteredCount > 0) {
                    let totalQuantity = 0;
                    let totalItems = 0;

                    filteredData.forEach(function(product) {
                        totalItems += 1;
                        const stock = Number(product.stock14 || 0) + Number(product.stock9013 || 0) + Number(product.stock9015 || 0);
                        if (Number.isFinite(stock)) {
                            totalQuantity += stock;
                        }
                    });

                    const quantityLabel = Number.isFinite(totalQuantity)
                        ? totalQuantity.toLocaleString('pt-BR')
                        : '--';

                    const scopeText = focusLabel
                        ? ` para <strong>${escapeTooltip(focusLabel)}</strong>`
                        : '';

                    messages.push(`
                        <div class="assistant-message">
                            <div class="assistant-avatar" aria-hidden="true">üì¶</div>
                            <div class="assistant-content">
                                <div class="assistant-text">Tenho ${escapeTooltip(totalItems.toString())} produto${totalItems === 1 ? '' : 's'}${scopeText} somando aproximadamente <strong>${escapeTooltip(quantityLabel)}</strong> unidades em estoque.</div>
                            </div>
                        </div>
                    `);

                    if (expectsExact) {
                        hasExactAnswer = true;
                    }
                } else {
                    messages.push(`
                        <div class="assistant-message">
                            <div class="assistant-avatar" aria-hidden="true">üì¶</div>
                            <div class="assistant-content">
                                <div class="assistant-text">N√£o localizei itens para avaliar o estoque. Especifique melhor o c√≥digo, nome ou fam√≠lia.</div>
                            </div>
                        </div>
                    `);
                }
            }

            if (messages.length === 0) {
                return null;
            }

            return {
                html: `<div class="assistant-panel">${messages.join('')}</div>`,
                hasExactAnswer: hasExactAnswer,
                expectsExact: expectsExact
            };
        }

        function performGlobalSearch() {
            const searchInput = document.getElementById('globalSearch');
            const resultsDiv = document.getElementById('searchResults');

            if (!searchInput || !resultsDiv) {
                return;
            }

            const rawValue = searchInput.value || '';
            const trimmedValue = rawValue.trim();
            const previousSelection = selectedSearchProduct;

            if (trimmedValue === '') {
                activeSearchContext = null;
                searchTerm = '';
                searchResultsCacheHtml = '';
                searchResultsHidden = false;
                resultsDiv.innerHTML = '';
                resultsDiv.classList.remove('is-hidden');
                resetSearchSelection();
                applyAllFilters();
                removeHighlights();
                updateSearchSelectionDisplay();
                return;
            }

            let context = null;
            if (window.searchIntelligence && typeof window.searchIntelligence.buildContext === 'function') {
                context = window.searchIntelligence.buildContext(trimmedValue);
                if (context && !context.hasMeaning) {
                    context = null;
                }
            }

            activeSearchContext = context;
            if (activeSearchContext && activeSearchContext.highlightTerm) {
                searchTerm = activeSearchContext.highlightTerm.toLowerCase();
            } else {
                searchTerm = trimmedValue.toLowerCase();
            }

            if (previousSelection) {
                const keepSelection = activeSearchContext && window.searchIntelligence && typeof window.searchIntelligence.matchesProduct === 'function'
                    ? window.searchIntelligence.matchesProduct(previousSelection, activeSearchContext)
                    : ((previousSelection.item || '').toString().toLowerCase().includes(searchTerm)
                        || (previousSelection.code || '').toString().toLowerCase().includes(searchTerm));

                if (!keepSelection) {
                    resetSearchSelection();
                }
            }

            applyAllFilters();

            const families = Array.from(new Set(allProductsData.map(function(product) {
                return (product.family || '').toString().trim();
            }).filter(function(value) { return value !== ''; }))).sort();
            const suppliers = Array.from(new Set(allProductsData.map(function(product) {
                return (product.supplier || '').toString().trim();
            }).filter(function(value) { return value !== ''; }))).sort();

            const familyCounts = new Map();
            const supplierCounts = new Map();

            allProductsData.forEach(function(product) {
                const familyName = (product.family || '').toString().trim();
                if (familyName !== '') {
                    familyCounts.set(familyName, (familyCounts.get(familyName) || 0) + 1);
                }

                const supplierName = (product.supplier || '').toString().trim();
                if (supplierName !== '') {
                    supplierCounts.set(supplierName, (supplierCounts.get(supplierName) || 0) + 1);
                }
            });

            const matchesContext = function(text) {
                const value = (text || '').toString();
                if (!value) {
                    return false;
                }

                if (activeSearchContext && window.searchIntelligence && typeof window.searchIntelligence.textMatchesContext === 'function') {
                    return window.searchIntelligence.textMatchesContext(value, activeSearchContext);
                }

                return value.toLowerCase().includes(searchTerm);
            };

            let productMatches = [];
            if (activeSearchContext && window.searchIntelligence && typeof window.searchIntelligence.rankProducts === 'function') {
                const ranked = window.searchIntelligence.rankProducts(allProductsData, activeSearchContext, 8);
                productMatches = ranked.map(function(entry) { return entry.product; });

                if (productMatches.length === 0 && activeSearchContext.highlightTerm) {
                    const fallbackTerm = activeSearchContext.highlightTerm.toLowerCase();
                    if (fallbackTerm) {
                        productMatches = allProductsData.filter(function(product) {
                            const code = (product.code || '').toString().toLowerCase();
                            const name = (product.item || '').toString().toLowerCase();
                            const supplier = (product.supplier || '').toString().toLowerCase();
                            const family = (product.family || '').toString().toLowerCase();
                            return code.includes(fallbackTerm)
                                || name.includes(fallbackTerm)
                                || supplier.includes(fallbackTerm)
                                || family.includes(fallbackTerm);
                        }).slice(0, 8);
                    }
                }
            } else {
                productMatches = allProductsData.filter(function(product) {
                    const code = (product.code || '').toString().toLowerCase();
                    const name = (product.item || '').toString().toLowerCase();
                    const supplier = (product.supplier || '').toString().toLowerCase();
                    const family = (product.family || '').toString().toLowerCase();
                    return code.includes(searchTerm)
                        || name.includes(searchTerm)
                        || supplier.includes(searchTerm)
                        || family.includes(searchTerm);
                }).slice(0, 8);
            }

            const familyMatches = families.filter(matchesContext).slice(0, 6);
            const supplierMatches = suppliers.filter(matchesContext).slice(0, 6);

            const filteredCount = filteredData.length;
            const summaryLabel = filteredCount === 1 ? 'produto' : 'produtos';
            const escapedTerm = escapeTooltip(trimmedValue);

            const conversationMatch = activeSearchContext && window.conversationParameters && typeof window.conversationParameters.resolve === 'function'
                ? window.conversationParameters.resolve(activeSearchContext)
                : null;
            const assistantPanel = buildAssistantPanel(activeSearchContext, productMatches, filteredCount, conversationMatch);

            const htmlParts = [];

            if (assistantPanel && assistantPanel.html) {
                htmlParts.push(assistantPanel.html);
            }

            htmlParts.push(`<div class="search-summary">üîç <strong>${filteredCount}</strong> ${summaryLabel} encontrados para "<em>${escapedTerm}</em>"</div>`);

            const shouldHideSuggestions = Boolean(assistantPanel && assistantPanel.hasExactAnswer);
            const suggestionGroups = {
                products: [],
                families: [],
                suppliers: []
            };

            let suggestionsCount = 0;

            if (!shouldHideSuggestions) {
                const maxSuggestions = 4;
                const hasCodeCandidates = Boolean(activeSearchContext && Array.isArray(activeSearchContext.codeCandidates) && activeSearchContext.codeCandidates.length > 0);
                const desiredEntity = activeSearchContext && activeSearchContext.intentMeta
                    ? activeSearchContext.intentMeta.desiredEntity
                    : null;
                const allowFamilySuggestions = desiredEntity === 'family' || (!hasCodeCandidates && !desiredEntity);
                const allowSupplierSuggestions = desiredEntity === 'supplier' || (!hasCodeCandidates && !desiredEntity);

                const buildProductSuggestion = function(product) {
                    const code = (product.code || '').toString().trim();
                    const name = (product.item || '').toString().trim() || code || 'Produto';
                    const family = (product.family || '').toString().trim();
                    const supplier = (product.supplier || '').toString().trim();
                    const metaParts = [];
                    if (code) { metaParts.push(`C√≥digo ${code}`); }
                    if (family) { metaParts.push(family); }
                    if (supplier) { metaParts.push(supplier); }
                    const metaHtml = metaParts.length > 0
                        ? `<span class="suggestion-meta">${escapeTooltip(metaParts.join(' ‚Ä¢ '))}</span>`
                        : '';
                    const targetTerm = code || name;
                    return `<button type="button" class="search-suggestion" data-suggestion-type="product" data-search-term="${escapeTooltip(targetTerm)}" data-product-code="${escapeTooltip(code)}">`
                        + `<span class="suggestion-icon" aria-hidden="true">üì¶</span>`
                        + `<span class="suggestion-content">`
                        + `<span class="suggestion-main">${escapeTooltip(name)}</span>`
                        + `${metaHtml}`
                        + `</span>`
                        + `<span class="suggestion-tag">Produto</span>`
                        + `</button>`;
                };

                const buildFamilySuggestion = function(family) {
                    const count = familyCounts.get(family) || 0;
                    const countLabel = count === 1 ? '1 item' : `${count} itens`;
                    return `<button type="button" class="search-suggestion" data-suggestion-type="family" data-family="${escapeTooltip(family)}">`
                        + `<span class="suggestion-icon" aria-hidden="true">üè∑Ô∏è</span>`
                        + `<span class="suggestion-content">`
                        + `<span class="suggestion-main">${escapeTooltip(family)}</span>`
                        + `<span class="suggestion-meta">${escapeTooltip(countLabel)}</span>`
                        + `</span>`
                        + `<span class="suggestion-tag">Filtrar fam√≠lia</span>`
                        + `</button>`;
                };

                const buildSupplierSuggestion = function(supplier) {
                    const count = supplierCounts.get(supplier) || 0;
                    const countLabel = count === 1 ? '1 item' : `${count} itens`;
                    return `<button type="button" class="search-suggestion" data-suggestion-type="supplier" data-supplier="${escapeTooltip(supplier)}">`
                        + `<span class="suggestion-icon" aria-hidden="true">üè≠</span>`
                        + `<span class="suggestion-content">`
                        + `<span class="suggestion-main">${escapeTooltip(supplier)}</span>`
                        + `<span class="suggestion-meta">${escapeTooltip(countLabel)}</span>`
                        + `</span>`
                        + `<span class="suggestion-tag">Filtrar fornecedor</span>`
                        + `</button>`;
                };

                productMatches.forEach(function(product) {
                    if (suggestionsCount >= maxSuggestions) {
                        return;
                    }
                    suggestionGroups.products.push(buildProductSuggestion(product));
                    suggestionsCount += 1;
                });

                if (suggestionsCount < maxSuggestions && allowFamilySuggestions) {
                    familyMatches.forEach(function(family) {
                        if (suggestionsCount >= maxSuggestions) {
                            return;
                        }
                        suggestionGroups.families.push(buildFamilySuggestion(family));
                        suggestionsCount += 1;
                    });
                }

                if (suggestionsCount < maxSuggestions && allowSupplierSuggestions) {
                    supplierMatches.forEach(function(supplier) {
                        if (suggestionsCount >= maxSuggestions) {
                            return;
                        }
                        suggestionGroups.suppliers.push(buildSupplierSuggestion(supplier));
                        suggestionsCount += 1;
                    });
                }

                if (suggestionGroups.products.length > 0) {
                    htmlParts.push(`<div class="search-suggestion-group" data-group="products">`
                        + `<span class="group-title">Produtos sugeridos</span>`
                        + `<div class="search-suggestion-list">${suggestionGroups.products.join('')}</div>`
                        + `</div>`);
                }

                if (suggestionGroups.families.length > 0) {
                    htmlParts.push(`<div class="search-suggestion-group" data-group="families">`
                        + `<span class="group-title">Fam√≠lias relacionadas</span>`
                        + `<div class="search-suggestion-list">${suggestionGroups.families.join('')}</div>`
                        + `</div>`);
                }

                if (suggestionGroups.suppliers.length > 0) {
                    htmlParts.push(`<div class="search-suggestion-group" data-group="suppliers">`
                        + `<span class="group-title">Fornecedores relacionados</span>`
                        + `<div class="search-suggestion-list">${suggestionGroups.suppliers.join('')}</div>`
                        + `</div>`);
                }
            }

            const resultsHtml = htmlParts.join('');

            searchResultsCacheHtml = resultsHtml;
            searchResultsHidden = false;
            resultsDiv.classList.remove('is-hidden');
            resultsDiv.innerHTML = resultsHtml;
            updateSearchSelectionDisplay();
        }

        function handleSearchSuggestionClick(event) {
            const button = event.target.closest('.search-suggestion, .assistant-action-chip');
            if (!button) {
                return;
            }

            event.preventDefault();

            const type = button.getAttribute('data-suggestion-type');
            if (!type) {
                return;
            }

            const resultsDiv = document.getElementById('searchResults');

            if (type === 'product') {
                const term = button.getAttribute('data-search-term') || '';
                if (term === '') {
                    return;
                }

                const searchInput = document.getElementById('globalSearch');
                const rawCode = (button.getAttribute('data-product-code') || '').trim();
                const normalizedCode = rawCode.toLowerCase();
                let matchedProduct = null;

                if (normalizedCode) {
                    matchedProduct = allProductsData.find(function(product) {
                        return (product.code || '').toString().trim().toLowerCase() === normalizedCode;
                    });
                }

                if (!matchedProduct && term) {
                    const normalizedTerm = term.toLowerCase();
                    matchedProduct = allProductsData.find(function(product) {
                        const codeValue = (product.code || '').toString().trim().toLowerCase();
                        const nameValue = (product.item || '').toString().trim().toLowerCase();
                        return codeValue === normalizedTerm || nameValue === normalizedTerm;
                    });
                }

                selectedSearchProduct = matchedProduct || null;

                if (searchInput) {
                    searchInput.value = term;
                    searchInput.focus();
                }

                performGlobalSearch();

                return;
            }

            if (type === 'product-history') {
                const productCode = (button.getAttribute('data-product-code') || '').trim();
                const searchTermValue = (button.getAttribute('data-search-term') || '').trim();

                if (!productCode) {
                    return;
                }

                const searchInput = document.getElementById('globalSearch');
                if (searchInput && searchTermValue) {
                    searchInput.value = searchTermValue;
                    searchInput.focus();
                }

                const normalizedCode = productCode.toLowerCase();
                const matchedProduct = allProductsData.find(function(product) {
                    return (product.code || '').toString().trim().toLowerCase() === normalizedCode;
                });

                selectedSearchProduct = matchedProduct || null;
                performGlobalSearch();
                openProductHistory(productCode);
                return;
            }

            if (type === 'family') {
                const family = (button.getAttribute('data-family') || '').trim();
                if (family === '') {
                    return;
                }

                resetSearchSelection();
                selectedSearchProduct = null;
                selectedFamily = family;
                criticalFilterActive = false;

                const familySelect = document.getElementById('familyFilter');
                if (familySelect) {
                    const hasOption = Array.from(familySelect.options || []).some(function(option) {
                        return option.value === family;
                    });

                    if (!hasOption) {
                        const option = document.createElement('option');
                        option.value = family;
                        option.textContent = family;
                        familySelect.appendChild(option);
                    }

                    familySelect.value = family;
                }

                const searchInput = document.getElementById('globalSearch');
                if (searchInput) {
                    searchInput.value = '';
                }

                searchTerm = '';
                applyAllFilters();
                refreshFamilyChipSelection();

                if (resultsDiv) {
                    const summaryHtml = `<div class="search-summary applied">Filtro de fam√≠lia "<em>${escapeTooltip(family)}</em>" aplicado.</div>`;
                    resultsDiv.innerHTML = summaryHtml;
                    searchResultsCacheHtml = summaryHtml;
                    searchResultsHidden = false;
                    resultsDiv.classList.remove('is-hidden');
                }

                return;
            }

            if (type === 'abc-class') {
                const abcClass = (button.getAttribute('data-abc-class') || '').trim();
                if (abcClass === '') {
                    return;
                }

                resetSearchSelection();
                selectedSearchProduct = null;
                const searchInput = document.getElementById('globalSearch');
                if (searchInput) {
                    searchInput.value = '';
                    searchInput.focus();
                }

                searchTerm = '';
                filterByAdvancedStock(abcClass);

                if (resultsDiv) {
                    const classLabel = abcClass.replace('abc-', '').toUpperCase();
                    const summaryHtml = `<div class="search-summary applied">Filtro ABC "<em>Classe ${escapeTooltip(classLabel)}</em>" aplicado.</div>`;
                    resultsDiv.innerHTML = summaryHtml;
                    searchResultsCacheHtml = summaryHtml;
                    searchResultsHidden = false;
                    resultsDiv.classList.remove('is-hidden');
                }

                return;
            }

            if (type === 'supplier') {
                const supplier = (button.getAttribute('data-supplier') || '').trim();
                if (supplier === '') {
                    return;
                }

                resetSearchSelection();
                selectedSearchProduct = null;
                selectedSupplier = supplier;
                criticalFilterActive = false;

                const supplierSelect = document.getElementById('supplierFilter');
                if (supplierSelect) {
                    const hasOption = Array.from(supplierSelect.options || []).some(function(option) {
                        return option.value === supplier;
                    });

                    if (!hasOption) {
                        const option = document.createElement('option');
                        option.value = supplier;
                        option.textContent = supplier;
                        supplierSelect.appendChild(option);
                    }

                    supplierSelect.value = supplier;
                }

                const searchInput = document.getElementById('globalSearch');
                if (searchInput) {
                    searchInput.value = '';
                }

                searchTerm = '';
                applyAllFilters();
                refreshFamilyChipSelection();

                if (resultsDiv) {
                    const summaryHtml = `<div class="search-summary applied">Filtro de fornecedor "<em>${escapeTooltip(supplier)}</em>" aplicado.</div>`;
                    resultsDiv.innerHTML = summaryHtml;
                    searchResultsCacheHtml = summaryHtml;
                    searchResultsHidden = false;
                    resultsDiv.classList.remove('is-hidden');
                }
            }
        }

        function resetAllFilters() {
            currentFilter = 'all';
            predictionFilter = null;
            selectedFamily = null;
            selectedSupplier = null;
            currentEstablishment = '';
            criticalFilterActive = false;

            resetAdvancedFilterSelection();
            resetCoverageFilterChips();
            resetPredictionRangeButtons();

            const familySelect = document.getElementById('familyFilter');
            const supplierSelect = document.getElementById('supplierFilter');
            const establishmentSelect = document.getElementById('establishmentFilter');

            if (familySelect) { familySelect.value = ''; }
            if (supplierSelect) { supplierSelect.value = ''; }
            if (establishmentSelect) { establishmentSelect.value = ''; }

            updateActiveButton('all');

            const activeItems = document.querySelectorAll('.prediction-item.active');
            activeItems.forEach(function(item) {
                item.classList.remove('active');
                item.setAttribute('aria-pressed', 'false');
            });

            refreshFamilyChipSelection();
        }

        function clearSearch() {
            const searchInput = document.getElementById('globalSearch');
            const resultsDiv = document.getElementById('searchResults');

            activeSearchContext = null;
            resetSearchSelection();

            if (searchInput) {
                searchInput.value = '';
            }

            if (resultsDiv) {
                resultsDiv.innerHTML = '';
                resultsDiv.classList.remove('is-hidden');
            }

            searchTerm = '';
            searchResultsCacheHtml = '';
            searchResultsHidden = false;

            applyAllFilters();
            removeHighlights();
        }

        function clearAllFilters() {
            resetAllFilters();

            const searchInput = document.getElementById('globalSearch');
            const resultsDiv = document.getElementById('searchResults');

            activeSearchContext = null;
            resetSearchSelection();

            if (searchInput) {
                searchInput.value = '';
            }

            if (resultsDiv) {
                resultsDiv.innerHTML = '';
                resultsDiv.classList.remove('is-hidden');
            }

            searchTerm = '';
            searchResultsCacheHtml = '';
            searchResultsHidden = false;

            removeHighlights();
            applyAllFilters();
        }

        function handleGlobalReset() {
            const hasContextSearch = Boolean(activeSearchContext && activeSearchContext.hasMeaning);
            if (hasContextSearch || (searchTerm && searchTerm.trim() !== '')) {
                clearSearch();
                return;
            }

            clearAllFilters();
        }

        function highlightSearchResults() {
            const gaugeCards = document.querySelectorAll('.gauge-card');
            gaugeCards.forEach(function(card) {
                const titleElement = card.querySelector('.gauge-title');
                const titleText = titleElement ? titleElement.textContent || '' : '';
                let shouldHighlight = false;

                if (activeSearchContext && window.searchIntelligence && typeof window.searchIntelligence.textMatchesContext === 'function') {
                    shouldHighlight = window.searchIntelligence.textMatchesContext(titleText, activeSearchContext);
                } else if (searchTerm) {
                    shouldHighlight = titleText.toLowerCase().includes(searchTerm);
                }

                if (shouldHighlight) {
                    card.classList.add('highlighted');
                } else {
                    card.classList.remove('highlighted');
                }
            });

            const tableRows = document.querySelectorAll('#productsTableBody tr');
            tableRows.forEach(function(row) {
                const rowText = row.textContent || '';
                let shouldHighlight = false;

                if (activeSearchContext && window.searchIntelligence && typeof window.searchIntelligence.textMatchesContext === 'function') {
                    shouldHighlight = window.searchIntelligence.textMatchesContext(rowText, activeSearchContext);
                } else if (searchTerm) {
                    shouldHighlight = rowText.toLowerCase().includes(searchTerm);
                }

                if (shouldHighlight) {
                    row.classList.add('highlighted');
                    row.classList.add('highlight-animation');
                } else {
                    row.classList.remove('highlighted');
                }
            });
        }

        function removeHighlights() {
            const highlighted = document.querySelectorAll('.highlighted');
            highlighted.forEach(function(el) {
                el.classList.remove('highlighted');
            });
            const animations = document.querySelectorAll('.highlight-animation');
            animations.forEach(function(el) {
                el.classList.remove('highlight-animation');
            });
        }

        function hideSearchResultsTemporarily() {
            const resultsDiv = document.getElementById('searchResults');
            if (!resultsDiv) {
                return;
            }

            const currentHtml = resultsDiv.innerHTML.trim();
            if (currentHtml !== '') {
                searchResultsCacheHtml = resultsDiv.innerHTML;
            } else {
                searchResultsCacheHtml = '';
            }

            resultsDiv.innerHTML = '';
            resultsDiv.classList.add('is-hidden');
            searchResultsHidden = true;
        }

        function restoreSearchResultsFromCache() {
            const resultsDiv = document.getElementById('searchResults');
            if (!resultsDiv) {
                return;
            }

            if (searchResultsHidden && searchResultsCacheHtml) {
                resultsDiv.innerHTML = searchResultsCacheHtml;
            }

            resultsDiv.classList.remove('is-hidden');
            searchResultsHidden = false;
        }

        // === FUN√á√ïES DE DADOS - VERS√ÉO CORRIGIDA ===
        function processCSV(csvText) {
            const lines = csvText.split('\n');
            if (lines.length < 2) return [];

            const headers = lines[0].split(',').map(function(h) {
                return h.trim().replace(/"/g, '');
            });
            const mapping = findColumnMapping(headers);
            const products = [];

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const values = parseCSVLine(line);
                if (values.length === 0) continue;

                while (values.length < headers.length) {
                    values.push('');
                }

                const product = mapProductData(headers, values, 'Arquivo CSV', mapping);
                if (product.code) {
                    products.push(product);
                }
            }

            return products;
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            
            result.push(current.trim());
            return result;
        }

        function processExcelRows(headers, rows, sheetName) {
            const products = [];
            const mapping = findColumnMapping(headers);

            rows.forEach(function(row) {
                if (!Array.isArray(row)) {
                    return;
                }

                const hasContent = row.some(function(cell) {
                    return hasMeaningfulValue(cell);
                });

                if (!hasContent) {
                    return;
                }

                const values = headers.map(function(_, index) {
                    return typeof row[index] !== 'undefined' ? row[index] : '';
                });

                const product = mapProductData(headers, values, sheetName, mapping);
                if (product.code) {
                    products.push(product);
                }
            });

            return products;
        }

        function mapProductData(headers, values, sheetName, mapping) {
            const columnMapping = mapping || findColumnMapping(headers);

            const rawStockMonthsCell = columnMapping.stockMonths !== undefined ? values[columnMapping.stockMonths] : null;
            const rawCoberturaCell = columnMapping.cobertura !== undefined ? values[columnMapping.cobertura] : null;

            const parsedStockMonths = parseNumber(rawStockMonthsCell);
            const parsedCobertura = parseNumber(rawCoberturaCell);

            const hasStockMonths = hasMeaningfulValue(rawStockMonthsCell);
            const hasCobertura = hasMeaningfulValue(rawCoberturaCell);
            const validStockMonths = hasStockMonths && Number.isFinite(parsedStockMonths);
            const validCobertura = hasCobertura && Number.isFinite(parsedCobertura);

            let effectiveCoverage = 0;
            let coverageSource = 'none';

            if (validStockMonths) {
                effectiveCoverage = parsedStockMonths;
                coverageSource = 'stockMonths';
            } else if (validCobertura) {
                effectiveCoverage = parsedCobertura;
                coverageSource = 'cobertura';
            }

            const product = {
                code: sanitizeText(values[columnMapping.code] || ''),
                supplier: sanitizeText(values[columnMapping.supplier] || ''),
                family: sanitizeText(values[columnMapping.family] || ''),
                item: sanitizeText(values[columnMapping.item] || ''),
                stock14: parseNumber(values[columnMapping.stock14] || 0),
                stock9013: parseNumber(values[columnMapping.stock9013] || 0),
                stock9015: parseNumber(values[columnMapping.stock9015] || 0),
                vendas4M: parseNumber(values[columnMapping.vendas4M] || 0),
                media3M: parseNumber(values[columnMapping.media3M]) || 0,
                novembro: parseNumber(values[columnMapping.novembro]) || 0,
                dezembro: parseNumber(values[columnMapping.dezembro]) || 0,
                cobertura: validCobertura ? parsedCobertura : null
            };

            product.stockMonths = Number.isFinite(effectiveCoverage) ? effectiveCoverage : 0;
            product.coverageSource = coverageSource;
            product.originSheet = sheetName || '';

            const monthlyValues = [];
            headers.forEach(function(header, index) {
                if (!header || !isMonthHeader(header)) {
                    return;
                }

                const rawValue = values[index];
                if (!hasMeaningfulValue(rawValue)) {
                    return;
                }

                const numericValue = parseNumber(rawValue);
                monthlyValues.push({
                    label: header.toString().trim(),
                    value: Number.isFinite(numericValue) ? numericValue : 0,
                    rawValue: rawValue
                });
            });

            product.sheetMonthlyValues = sortMonthlyValues(monthlyValues);

            return product;
        }

        function mergeProductIntoMap(map, product, sheetName) {
            if (!product || !product.code) {
                return;
            }

            const monthlyValues = cloneMonthlyValues(product.sheetMonthlyValues);
            const historyEntry = createHistoryEntry(product, sheetName || product.originSheet || '');

            if (!map.has(product.code)) {
                const newProduct = Object.assign({}, product);
                newProduct.monthlyValues = aggregateMonthlyValues([], monthlyValues);
                newProduct.importHistory = [historyEntry];
                newProduct.latestSheet = sheetName || product.originSheet || '';
                delete newProduct.sheetMonthlyValues;
                delete newProduct.originSheet;
                map.set(product.code, newProduct);
                return;
            }

            const existing = map.get(product.code);
            existing.importHistory = Array.isArray(existing.importHistory) ? existing.importHistory : [];
            existing.importHistory.push(historyEntry);
            existing.latestSheet = sheetName || existing.latestSheet || '';

            existing.monthlyValues = aggregateMonthlyValues(existing.monthlyValues || [], monthlyValues);

            existing.supplier = product.supplier || existing.supplier;
            existing.family = product.family || existing.family;
            existing.item = product.item || existing.item;
            existing.stock14 = product.stock14;
            existing.stock9013 = product.stock9013;
            existing.stock9015 = product.stock9015;
            existing.stockMonths = product.stockMonths;
            existing.vendas4M = product.vendas4M;
            existing.media3M = product.media3M;
            existing.novembro = product.novembro;
            existing.dezembro = product.dezembro;
            existing.cobertura = product.cobertura;
            existing.coverageSource = product.coverageSource;

            delete existing.sheetMonthlyValues;
            delete existing.originSheet;
        }

        function finalizeProductList(products, sheetName) {
            const productMap = new Map();
            (Array.isArray(products) ? products : []).forEach(function(product) {
                mergeProductIntoMap(productMap, product, sheetName || product.originSheet || '');
            });
            return Array.from(productMap.values()).sort(function(a, b) {
                return a.code.localeCompare(b.code, 'pt-BR', { sensitivity: 'base', numeric: true });
            });
        }

        function mergeWorkbookData(workbook, sheetNames) {
            const productMap = new Map();
            const processedSheets = [];

            sheetNames.forEach(function(sheetName) {
                try {
                    const sheetData = extractWorkbookData(workbook, sheetName);
                    if (!Array.isArray(sheetData) || sheetData.length === 0) {
                        debugLog(`Aba "${sheetName}" sem dados relevantes ou vazia.`, 'warn');
                        return;
                    }

                    sheetData.forEach(function(product) {
                        mergeProductIntoMap(productMap, product, sheetName);
                    });

                    processedSheets.push({
                        name: sheetName,
                        count: sheetData.length
                    });
                } catch (error) {
                    debugLog(`Erro ao processar aba "${sheetName}": ${error.message}`, 'error');
                }
            });

            const combinedData = Array.from(productMap.values()).sort(function(a, b) {
                return a.code.localeCompare(b.code, 'pt-BR', { sensitivity: 'base', numeric: true });
            });

            return { combinedData, processedSheets };
        }

        // FUN√á√ÉO ATUALIZADA v1.3.0 - Mapeamento Espec√≠fico para sua Planilha
        function findColumnMapping(headers) {
            debugLog('=== MAPEAMENTO v1.3.0 - AN√ÅLISE ESPEC√çFICA ===');
            debugLog(`Colunas encontradas: ${headers.length}`);

            headers.forEach(function(h, index) {
                debugLog(`[${index}] "${h}"`);
            });

            const upperHeaders = headers.map(function(header) {
                return (header || '').toString().toUpperCase().trim();
            });
            const normalizedHeaders = headers.map(function(header) {
                return (header || '')
                    .toString()
                    .normalize('NFD')
                    .replace(/[\u0300-\u036f]/g, '')
                    .toUpperCase()
                    .replace(/[^A-Z0-9]/g, '');
            });

            const mapping = {};
            const warnings = [];
            const headerCount = headers.length;

            function assignField(field, index, detail) {
                if (typeof index === 'number' && index >= 0) {
                    mapping[field] = index;
                    const label = headers[index] || '';
                    const suffix = detail ? ` ${detail}` : '';
                    debugLog(`‚úÖ ${field} ‚Üí [${index}] "${label}"${suffix}`);
                }
            }

            function findIndex(predicate) {
                for (let i = 0; i < headerCount; i++) {
                    if (predicate(i, upperHeaders[i], normalizedHeaders[i])) {
                        return i;
                    }
                }
                return undefined;
            }

            assignField('code', findIndex(function(_, upper) {
                return upper === 'C√ìDIGO' || upper === 'CODIGO' || upper === 'CODE';
            }));

            assignField('supplier', findIndex(function(_, upper) {
                return upper === 'FORNECEDOR' || upper === 'SUPPLIER';
            }));

            assignField('family', findIndex(function(_, upper) {
                return upper === 'FAM√çLIA' || upper === 'FAMILIA' || upper === 'FAMILY';
            }));

            assignField('item', findIndex(function(_, upper) {
                return upper === 'ITEM' || upper === 'PRODUTO' || upper === 'PRODUCT';
            }));

            for (let i = 0; i < headerCount; i++) {
                const upper = upperHeaders[i];
                if (mapping.stock14 === undefined && (upper === '1-4' || upper === '1_4' || upper.includes('1-4'))) {
                    assignField('stock14', i);
                } else if (mapping.stock9013 === undefined && (upper === '90-13' || upper === '90_13' || upper.includes('90-13'))) {
                    assignField('stock9013', i);
                } else if (mapping.stock9015 === undefined && (upper === '90-15' || upper === '90_15' || upper.includes('90-15'))) {
                    assignField('stock9015', i);
                }
            }

            assignField('stockMonths', findIndex(function(_, upper, normalized) {
                return (upper.includes('ESTOQUE') && upper.includes('MESES')) || normalized.includes('STOCKMONTHS');
            }));

            assignField('cobertura', findIndex(function(_, __, normalized) {
                return normalized.includes('COBERTURA') || normalized.includes('COVERAGE');
            }));

            let vendasIndex = findIndex(function(_, __, normalized) {
                return normalized.includes('VENDAS4');
            });
            if (typeof vendasIndex === 'number') {
                assignField('vendas4M', vendasIndex);
            } else {
                vendasIndex = findIndex(function(_, __, normalized) {
                    return normalized.includes('VENDAS3');
                });
                if (typeof vendasIndex === 'number') {
                    assignField('vendas4M', vendasIndex, '(usando VENDAS 3M)');
                    warnings.push('Coluna VENDAS 3M n√£o encontrada; utilizando VENDAS 3M da planilha.');
                }
            }

            assignField('media3M', findIndex(function(_, __, normalized) {
                return normalized.includes('MEDIA3');
            }));

            const novembroIndex = findIndex(function(_, __, normalized) {
                return normalized.includes('NOVEMBRO');
            });
            if (typeof novembroIndex === 'number') {
                assignField('novembro', novembroIndex);
            } else {
                warnings.push('Coluna NOVEMBRO n√£o encontrada na planilha.');
                debugLog('‚ö†Ô∏è Coluna NOVEMBRO n√£o identificada nos cabe√ßalhos recebidos.');
            }

            const dezembroIndex = findIndex(function(_, __, normalized) {
                return normalized.includes('DEZEMBRO');
            });
            if (typeof dezembroIndex === 'number') {
                assignField('dezembro', dezembroIndex);
            } else {
                warnings.push('Coluna DEZEMBRO n√£o encontrada na planilha.');
                debugLog('‚ö†Ô∏è Coluna DEZEMBRO n√£o identificada nos cabe√ßalhos recebidos.');
            }

            if (mapping.stockMonths === undefined && mapping.cobertura !== undefined) {
                mapping.stockMonths = mapping.cobertura;
                warnings.push('Coluna ESTOQUE EM MESES n√£o encontrada; usando COBERTURA da planilha.');
                debugLog('üîÑ stockMonths ‚Üí cobertura (fallback)');
            }

            if (mapping.cobertura === undefined && mapping.stockMonths !== undefined) {
                mapping.cobertura = mapping.stockMonths;
                warnings.push('Coluna COBERTURA n√£o encontrada; usando ESTOQUE EM MESES como refer√™ncia.');
                debugLog('üîÑ cobertura ‚Üí stockMonths (fallback)');
            }

            if (mapping.stock9015 === undefined) {
                warnings.push('CR√çTICO: Coluna 90-15 N√ÉO ENCONTRADA!');
                debugLog('üö® CR√çTICO: Coluna 90-15 N√ÉO ENCONTRADA na planilha!');
            } else {
                const mappedHeader = headers[mapping.stock9015];
                if (mappedHeader !== '90-15' && mappedHeader !== '90_15') {
                    warnings.push(`ATEN√á√ÉO: stock9015 mapeado para "${mappedHeader}" em vez de "90-15"`);
                    debugLog(`‚ö†Ô∏è stock9015 mapeado para "${mappedHeader}" - pode estar incorreto`);
                }
            }

            debugLog('=== MAPEAMENTO FINAL v1.3.0 ===');
            Object.entries(mapping).forEach(function([field, index]) {
                const header = headers[index] || 'INV√ÅLIDO';
                debugLog(`${field.padEnd(12)} ‚Üí [${index}] "${header}"`);
            });

            const requiredFields = {
                code: 'C√ìDIGO',
                supplier: 'FORNECEDOR',
                family: 'FAM√çLIA',
                item: 'ITEM',
                stock14: '1-4',
                stock9013: '90-13',
                stock9015: '90-15',
                vendas4M: 'VENDAS 3M',
                media3M: 'M√âDIA 3M',
                stockMonths: 'ESTOQUE EM MESES/COBERTURA'
            };

            const missingFields = Object.keys(requiredFields).filter(function(field) {
                return typeof mapping[field] !== 'number';
            });

            lastMappingInfo = {
                headers: headers.slice(),
                mapping: Object.assign({}, mapping),
                warnings: warnings.slice(),
                version: '1.3.0'
            };

            debugLog(`=== MAPEAMENTO v1.3.0 CONCLU√çDO - ${warnings.length} avisos ===`);
            warnings.forEach(function(warning) {
                debugLog(`‚ö†Ô∏è ${warning}`);
            });

            if (missingFields.length > 0) {
                const labels = missingFields.map(function(field) { return requiredFields[field]; });
                const error = new Error(`N√£o foi poss√≠vel identificar as colunas obrigat√≥rias: ${labels.join(', ')}`);
                error.missingFields = labels;
                error.mappingInfo = lastMappingInfo;
                throw error;
            }

            if (mappingDebugMode) {
                showMappingInfo(lastMappingInfo);
            }

            return mapping;
        }

        function sanitizeText(text) {
            if (!text) return '';
            return text.toString().trim().replace(/"/g, '');
        }

        function parseNumber(value) {
            if (value === null || typeof value === 'undefined') {
                return 0;
            }

            const stringValue = value.toString().trim();
            if (stringValue === '') {
                return 0;
            }

            const sanitized = stringValue.replace(/\s+/g, '');
            const digitsOnly = sanitized.replace(/[^0-9.,-]/g, '');
            if (digitsOnly === '' || digitsOnly === '-' || digitsOnly === ',' || digitsOnly === '.') {
                return 0;
            }

            const hasComma = digitsOnly.includes(',');
            const hasDot = digitsOnly.includes('.');
            let normalized = digitsOnly;

            const brazilianThousandPattern = /^-?\d{1,3}(\.\d{3})+(,\d+)?$/;
            const americanThousandPattern = /^-?\d{1,3}(,\d{3})+(\.\d+)?$/;

            if (brazilianThousandPattern.test(digitsOnly)) {
                normalized = digitsOnly.replace(/\./g, '').replace(',', '.');
            } else if (americanThousandPattern.test(digitsOnly)) {
                normalized = digitsOnly.replace(/,/g, '');
            } else if (hasComma && hasDot) {
                if (digitsOnly.lastIndexOf(',') > digitsOnly.lastIndexOf('.')) {
                    normalized = digitsOnly.replace(/\./g, '').replace(',', '.');
                } else {
                    normalized = digitsOnly.replace(/,/g, '');
                }
            } else if (hasComma) {
                normalized = digitsOnly.replace(/\./g, '').replace(',', '.');
            } else if (hasDot) {
                const dotCount = (digitsOnly.match(/\./g) || []).length;
                if (dotCount > 1) {
                    normalized = digitsOnly.replace(/\./g, '');
                } else {
                    const decimalPart = digitsOnly.split('.')[1] || '';
                    if (decimalPart.length === 3 && digitsOnly.length > 4) {
                        normalized = digitsOnly.replace(/\./g, '');
                    }
                }
            }

            const parsed = parseFloat(normalized);
            return Number.isFinite(parsed) ? parsed : 0;
        }

        // === FUN√á√ïES DE FILTROS ===
        function setPredictionCardActive(card, isActive) {
            if (!card) {
                return;
            }

            if (isActive) {
                card.classList.add('active');
                card.dataset.active = 'true';
            } else {
                card.classList.remove('active');
                delete card.dataset.active;
            }
        }

        function getPredictionFilterForBucket(bucket) {
            switch (bucket) {
                case 'urgent':
                    return 'zero30';
                case 'warning':
                    return 'zero60';
                case 'comfortable':
                    return 'comfortable';
                default:
                    return null;
            }
        }

        function clearActiveRiskSelection(options) {
            const opts = options || {};
            if (!activeRiskSelection) {
                hideRiskChartTooltip();
                return;
            }

            hideRiskChartTooltip();
            activeRiskSelection = null;
            updateRiskSelectionStyles();

            if (!opts.silent) {
                applyAllFilters();
            }
        }

        function updateRiskSelectionStyles() {
            Object.keys(riskChartInstances).forEach(function(chartId) {
                const chart = riskChartInstances[chartId];
                if (!chart || typeof chart.setActiveElements !== 'function') {
                    return;
                }

                const selection = activeRiskSelection && activeRiskSelection.chartId === chartId
                    ? activeRiskSelection
                    : null;

                if (selection && Number.isInteger(selection.index)) {
                    chart.setActiveElements([{ datasetIndex: 0, index: selection.index }]);
                } else {
                    chart.setActiveElements([]);
                }

                chart.update('none');
            });

            document.querySelectorAll('.prediction-legend-item').forEach(function(button) {
                const chartId = button.getAttribute('data-chart-id');
                const index = Number(button.getAttribute('data-segment-index'));
                const isActive = !!activeRiskSelection
                    && activeRiskSelection.chartId === chartId
                    && Number.isInteger(activeRiskSelection.index)
                    && activeRiskSelection.index === index;

                if (isActive) {
                    button.classList.add('is-active');
                } else {
                    button.classList.remove('is-active');
                    if (button.hasAttribute('aria-pressed')) {
                        button.setAttribute('aria-pressed', 'false');
                    }
                }
            });
        }

        function handleRiskSegmentSelection(config, segment, index) {
            if (!config || !segment) {
                return;
            }

            hideRiskChartTooltip();

            const codes = Array.isArray(segment.codes) ? segment.codes.filter(Boolean) : [];
            const chartId = config.chartId || '';
            const bucket = config.bucket || '';

            const isSameSelection = !!activeRiskSelection
                && activeRiskSelection.chartId === chartId
                && activeRiskSelection.bucket === bucket
                && activeRiskSelection.label === segment.label;

            if (isSameSelection) {
                const expectedFilter = getPredictionFilterForBucket(bucket);
                clearActiveRiskSelection();

                if (expectedFilter === 'zero30' && predictionFilter === 'zero30') {
                    filterZeroIn30();
                } else if (expectedFilter === 'zero60' && predictionFilter === 'zero60') {
                    filterZeroIn60();
                } else if (expectedFilter === 'comfortable' && predictionFilter === 'comfortable') {
                    filterComfortableCoverage();
                }
                return;
            }

            activeRiskSelection = {
                bucket: bucket,
                chartId: chartId,
                label: segment.label,
                normalizedLabel: segment.normalizedLabel,
                codes: codes,
                index: index
            };

            const expectedFilter = getPredictionFilterForBucket(bucket);
            if (expectedFilter === 'zero30' && predictionFilter !== 'zero30') {
                filterZeroIn30();
                return;
            }

            if (expectedFilter === 'zero60' && predictionFilter !== 'zero60') {
                filterZeroIn60();
                return;
            }

            if (expectedFilter === 'comfortable' && predictionFilter !== 'comfortable') {
                filterComfortableCoverage();
                return;
            }

            applyAllFilters();
        }

        function setupRiskLegendInteractions(legendElement) {
            if (!legendElement) {
                return;
            }

            legendElement.setAttribute('role', 'list');
        }

        function resetPredictionRangeButtons() {
            const rangeButtons = document.querySelectorAll('[data-prediction-filter]');
            rangeButtons.forEach(function(button) {
                setPredictionCardActive(button, false);
            });
        }

        function resetCoverageFilterChips() {
            const chips = document.querySelectorAll('.prediction-item[data-coverage-filter].active');
            chips.forEach(function(chip) {
                chip.classList.remove('active');
                chip.setAttribute('aria-pressed', 'false');
            });
        }

        function populateFamilyFilter() {
            const families = [...new Set(allProductsData.map(function(p) {
                return p.family;
            }))].sort();
            const select = document.getElementById('familyFilter');
            select.innerHTML = '<option value="">Todas as Fam√≠lias</option>';
            families.forEach(function(family) {
                const option = document.createElement('option');
                const normalized = (family || '').toString().trim();
                option.value = normalized;
                option.textContent = family;
                select.appendChild(option);
            });
        }

        function populateSupplierFilter() {
            const suppliers = [...new Set(allProductsData.map(function(p) {
                return p.supplier;
            }))].sort();
            const select = document.getElementById('supplierFilter');
            select.innerHTML = '<option value="">Todos os Fornecedores</option>';
            suppliers.forEach(function(supplier) {
                const option = document.createElement('option');
                option.value = supplier;
                option.textContent = supplier;
                select.appendChild(option);
            });
        }

        function showAllProducts() {
            currentFilter = 'all';
            predictionFilter = null;
            selectedFamily = null;
            selectedSupplier = null;
            criticalFilterActive = false;
            const activeItems = document.querySelectorAll('.prediction-item.active');
            activeItems.forEach(function(item) {
                item.classList.remove('active');
                item.setAttribute('aria-pressed', 'false');
            });
            resetPredictionRangeButtons();
            document.getElementById('familyFilter').value = '';
            document.getElementById('supplierFilter').value = '';
            document.getElementById('establishmentFilter').value = '';
            resetAdvancedFilterSelection();
            updateActiveButton('all');
            refreshFamilyChipSelection();
            applyAllFilters();
        }

        function filterCriticalStock() {
            const chip = document.querySelector('.prediction-item[data-coverage-filter="critical"]');
            if (chip && chip.classList.contains('is-empty')) {
                return;
            }
            const wasActive = criticalFilterActive;
            predictionFilter = null;
            resetAdvancedFilterSelection();
            resetPredictionRangeButtons();

            if (wasActive) {
                criticalFilterActive = false;
                currentFilter = 'all';
            } else {
                criticalFilterActive = true;
                currentFilter = 'critical';
            }

            updateActiveButton(currentFilter === 'all' ? 'all' : null);
            applyAllFilters();
        }

        function filterLowStock() {
            const chip = document.querySelector('.prediction-item[data-coverage-filter="low"]');
            if (chip && chip.classList.contains('is-empty')) {
                return;
            }
            predictionFilter = null;
            criticalFilterActive = false;
            resetAdvancedFilterSelection();
            resetPredictionRangeButtons();

            if (!predictionFilter && currentFilter === 'low') {
                currentFilter = 'all';
            } else {
                currentFilter = 'low';
            }

            updateActiveButton(currentFilter === 'all' ? 'all' : null);
            applyAllFilters();
        }

        function filterHighStock() {
            const chip = document.querySelector('.prediction-item[data-coverage-filter="high"]');
            if (chip && chip.classList.contains('is-empty')) {
                return;
            }
            predictionFilter = null;
            criticalFilterActive = false;
            resetAdvancedFilterSelection();
            resetPredictionRangeButtons();

            if (!predictionFilter && currentFilter === 'high') {
                currentFilter = 'all';
            } else {
                currentFilter = 'high';
            }

            updateActiveButton(currentFilter === 'all' ? 'all' : null);
            applyAllFilters();
        }

        function filterByFamily() {
            const familyDropdown = document.getElementById('familyFilter');
            const rawValue = familyDropdown ? familyDropdown.value : '';
            const normalizedValue = typeof rawValue === 'string' ? rawValue.trim() : '';
            selectedFamily = normalizedValue ? normalizedValue : null;
            criticalFilterActive = false;
            refreshFamilyChipSelection();
            applyAllFilters();
        }

        function filterBySupplier() {
            const supplierDropdown = document.getElementById('supplierFilter');
            selectedSupplier = supplierDropdown.value;
            criticalFilterActive = false;
            applyAllFilters();
        }

        function filterByEstablishment() {
            currentEstablishment = document.getElementById('establishmentFilter').value;
            criticalFilterActive = false;
            applyAllFilters();
        }

        function filterByAdvancedStock(value) {
            if (typeof value === 'string') {
                const normalized = value.trim();
                const chip = document.querySelector(`.prediction-item[data-advanced-filter="${normalized}"]`);
                if (chip && chip.classList.contains('is-empty')) {
                    return;
                }
                if (advancedStockFilter === normalized) {
                    resetAdvancedFilterSelection();
                } else {
                    advancedStockFilter = normalized;
                    currentFilter = 'all';
                    predictionFilter = null;
                    resetCoverageFilterChips();
                    resetPredictionRangeButtons();
                    syncAdvancedFilterChips();
                }
            } else {
                resetAdvancedFilterSelection();
            }

            criticalFilterActive = false;
            updateActiveButton('all');
            refreshFamilyChipSelection();
            applyAllFilters();
        }

        function filterByGauge(family) {
            const normalizedFamily = typeof family === 'string' ? family.trim() : '';
            toggleFamilyFilterSelection(normalizedFamily);
        }

        function filterZeroIn30() {
            const item30 = document.querySelector('[data-prediction-filter="zero30"]');
            const item60 = document.querySelector('[data-prediction-filter="zero60"]');
            const comfortable = document.querySelector('[data-prediction-filter="comfortable"]');

            resetAdvancedFilterSelection();

            if (predictionFilter === 'zero30') {
                predictionFilter = null;
                currentFilter = 'all';
                criticalFilterActive = false;
                setPredictionCardActive(item30, false);
                setPredictionCardActive(item60, false);
                setPredictionCardActive(comfortable, false);
                clearActiveRiskSelection({ silent: true });
            } else {
                resetCoverageFilterChips();
                resetPredictionRangeButtons();

                predictionFilter = 'zero30';
                criticalFilterActive = false;
                currentFilter = 'prediction30';
                setPredictionCardActive(item30, true);
                setPredictionCardActive(item60, false);
                setPredictionCardActive(comfortable, false);
            }

            updateActiveButton(currentFilter === 'all' ? 'all' : null);
            applyAllFilters();
        }

        function filterZeroIn60() {
            const item30 = document.querySelector('[data-prediction-filter="zero30"]');
            const item60 = document.querySelector('[data-prediction-filter="zero60"]');
            const comfortable = document.querySelector('[data-prediction-filter="comfortable"]');

            resetAdvancedFilterSelection();

            if (predictionFilter === 'zero60') {
                predictionFilter = null;
                currentFilter = 'all';
                criticalFilterActive = false;
                setPredictionCardActive(item60, false);
                setPredictionCardActive(item30, false);
                setPredictionCardActive(comfortable, false);
                clearActiveRiskSelection({ silent: true });
            } else {
                resetCoverageFilterChips();
                resetPredictionRangeButtons();

                predictionFilter = 'zero60';
                criticalFilterActive = false;
                currentFilter = 'prediction60';
                setPredictionCardActive(item30, false);
                setPredictionCardActive(item60, true);
                setPredictionCardActive(comfortable, false);
            }

            updateActiveButton(currentFilter === 'all' ? 'all' : null);
            applyAllFilters();
        }

        function filterComfortableCoverage() {
            const item30 = document.querySelector('[data-prediction-filter="zero30"]');
            const item60 = document.querySelector('[data-prediction-filter="zero60"]');
            const comfortable = document.querySelector('[data-prediction-filter="comfortable"]');

            resetAdvancedFilterSelection();

            if (predictionFilter === 'comfortable') {
                predictionFilter = null;
                currentFilter = 'all';
                criticalFilterActive = false;
                setPredictionCardActive(comfortable, false);
                setPredictionCardActive(item30, false);
                setPredictionCardActive(item60, false);
                clearActiveRiskSelection({ silent: true });
            } else {
                resetCoverageFilterChips();
                resetPredictionRangeButtons();

                predictionFilter = 'comfortable';
                criticalFilterActive = false;
                currentFilter = 'comfortable';
                setPredictionCardActive(item30, false);
                setPredictionCardActive(item60, false);
                setPredictionCardActive(comfortable, true);
            }

            updateActiveButton(currentFilter === 'all' ? 'all' : null);
            applyAllFilters();
        }

        function assignAbcClassification(dataSet) {
            const classificationMap = new Map();

            if (!Array.isArray(dataSet) || dataSet.length === 0) {
                abcClassificationMap = classificationMap;
                if (Array.isArray(dataSet)) {
                    dataSet.forEach(function(product) {
                        product.currentAbcClass = '‚Äî';
                        product.individualSalesShare = 0;
                        product.cumulativeSalesShare = 0;
                    });
                }
                return classificationMap;
            }

            const sortedData = dataSet.slice().sort(function(a, b) {
                return (b.vendas4M || 0) - (a.vendas4M || 0);
            });

            const totalSales = sortedData.reduce(function(sum, product) {
                const sales = Math.max(product.vendas4M || 0, 0);
                return sales > 0 ? sum + sales : sum;
            }, 0);

            if (totalSales === 0) {
                sortedData.forEach(function(product) {
                    classificationMap.set(product.code, '‚Äî');
                    product.currentAbcClass = '‚Äî';
                    product.individualSalesShare = 0;
                    product.cumulativeSalesShare = 0;
                });
                abcClassificationMap = classificationMap;
                return classificationMap;
            }

            let hasClassA = false;
            let hasClassB = false;

            sortedData.forEach(function(product) {
                const sales = Math.max(product.vendas4M || 0, 0);
                const individualShare = totalSales === 0 ? 0 : sales / totalSales;
                product.individualSalesShare = individualShare;
                product.cumulativeSalesShare = individualShare;

                let classification = 'C';
                if (individualShare >= abcIndividualThresholds.classA) {
                    classification = 'A';
                    hasClassA = true;
                } else if (individualShare >= abcIndividualThresholds.classB) {
                    classification = 'B';
                    hasClassB = true;
                }

                classificationMap.set(product.code, classification);
            });

            if (!hasClassA && sortedData.length > 0) {
                const topProduct = sortedData[0];
                classificationMap.set(topProduct.code, 'A');
            }

            if (!hasClassB && sortedData.length > 1) {
                let candidate = sortedData.find(function(product) {
                    return classificationMap.get(product.code) !== 'A' && (product.vendas4M || 0) > 0;
                });
                if (!candidate) {
                    candidate = sortedData.find(function(product) {
                        return classificationMap.get(product.code) !== 'A';
                    });
                }
                if (candidate) {
                    classificationMap.set(candidate.code, 'B');
                }
            }

            dataSet.forEach(function(product) {
                const classification = classificationMap.get(product.code) || '‚Äî';
                product.currentAbcClass = classification;
                if (!classificationMap.has(product.code)) {
                    classificationMap.set(product.code, classification);
                }
            });

            abcClassificationMap = classificationMap;
            return classificationMap;
        }

        function getCoverageMonthsForProduct(product) {
            const directValue = getCoverageValue(product);
            if (Number.isFinite(directValue)) {
                return directValue;
            }

            const coverageInfo = getCoverageInfo(product);
            if (coverageInfo.outOfStock) {
                return 0;
            }

            if (Number.isFinite(coverageInfo.daysToDepletion)) {
                return coverageInfo.daysToDepletion / 30;
            }

            return null;
        }

        function computeCoverageSegments(dataSet) {
            const segments = { critical: 0, low: 0, slow: 0 };

            if (!Array.isArray(dataSet) || dataSet.length === 0) {
                return segments;
            }

            dataSet.forEach(function(product) {
                const coverageValue = getCoverageMonthsForProduct(product);
                if (!Number.isFinite(coverageValue)) {
                    return;
                }

                if (coverageValue < coverageSegmentThresholds.critical) {
                    segments.critical += 1;
                } else if (coverageValue < coverageSegmentThresholds.lowUpper) {
                    segments.low += 1;
                } else {
                    segments.slow += 1;
                }
            });

            return segments;
        }

        function computeAdvancedFilterSegments(dataSet) {
            const segments = {
                'no-stock': 0,
                'over50': 0,
                'abc-a': 0,
                'abc-b': 0,
                'abc-c': 0,
                'hot-demand': 0,
                'top-sellers-risk': 0,
                'stagnant-stock': 0
            };

            if (!Array.isArray(dataSet) || dataSet.length === 0) {
                return segments;
            }

            dataSet.forEach(function(product) {
                if (getProductStock(product) <= 0) {
                    segments['no-stock'] += 1;
                }

                const coverage = getCoverageInfo(product);
                let coverageMonths = null;
                if (coverage && coverage.daysToDepletion !== null) {
                    coverageMonths = coverage.daysToDepletion / 30;
                } else if (Number.isFinite(product && product.stockMonths)) {
                    coverageMonths = product.stockMonths;
                }

                if (Number.isFinite(coverageMonths) && coverageMonths > 50) {
                    segments['over50'] += 1;
                }

                const monthlyAverage = Number.isFinite(product && product.media3M)
                    ? Number(product.media3M)
                    : 0;
                const salesFourMonths = Number.isFinite(product && product.vendas4M)
                    ? Number(product.vendas4M)
                    : 0;

                if (Number.isFinite(coverageMonths) && coverageMonths < 1.5 && monthlyAverage > 0) {
                    segments['hot-demand'] += 1;
                }

                if (Number.isFinite(coverageMonths) && coverageMonths < 2 && salesFourMonths > 10000) {
                    segments['top-sellers-risk'] += 1;
                }

                if (Number.isFinite(coverageMonths) && coverageMonths > 8 && monthlyAverage < 500) {
                    segments['stagnant-stock'] += 1;
                }

                const abcClass = (product && product.currentAbcClass) || '‚Äî';
                if (abcClass === 'A') {
                    segments['abc-a'] += 1;
                } else if (abcClass === 'B') {
                    segments['abc-b'] += 1;
                } else if (abcClass === 'C') {
                    segments['abc-c'] += 1;
                }
            });

            return segments;
        }

        function formatChipCount(count) {
            const safeCount = Number(count) || 0;
            const label = safeCount === 1 ? 'item' : 'itens';
            return `${safeCount} ${label}`;
        }

        function resetAdvancedFilterChips() {
            const chips = document.querySelectorAll('.prediction-item[data-advanced-filter]');
            chips.forEach(function(chip) {
                chip.classList.remove('active');
                chip.setAttribute('aria-pressed', 'false');
            });
        }

        function syncAdvancedFilterChips() {
            const chips = document.querySelectorAll('.prediction-item[data-advanced-filter]');
            chips.forEach(function(chip) {
                const key = chip.getAttribute('data-advanced-filter');
                const isActive = advancedStockFilter === key;
                if (isActive) {
                    chip.classList.add('active');
                    chip.setAttribute('aria-pressed', 'true');
                } else {
                    chip.classList.remove('active');
                    chip.setAttribute('aria-pressed', 'false');
                }
            });
        }

        function updateAdvancedFilterChips(segments) {
            const chips = document.querySelectorAll('.prediction-item[data-advanced-filter]');
            chips.forEach(function(chip) {
                const key = chip.getAttribute('data-advanced-filter');
                const count = segments[key] || 0;
                const counter = chip.querySelector('.filter-count');
                if (counter) {
                    counter.textContent = formatChipCount(count);
                }

                if (count === 0) {
                    chip.classList.add('is-empty');
                    chip.setAttribute('aria-disabled', 'true');
                } else {
                    chip.classList.remove('is-empty');
                    chip.removeAttribute('aria-disabled');
                }
            });

            syncAdvancedFilterChips();
        }

        function resetAdvancedFilterSelection() {
            advancedStockFilter = '';
            resetAdvancedFilterChips();
            syncAdvancedFilterChips();
        }

        function updateCoverageQuickFilters(segments) {
            const safeSegments = segments || { critical: 0, low: 0, slow: 0 };
            const counts = {
                critical: Number.isFinite(safeSegments.critical) ? safeSegments.critical : 0,
                low: Number.isFinite(safeSegments.low) ? safeSegments.low : 0,
                slow: Number.isFinite(safeSegments.slow) ? safeSegments.slow : 0
            };

            const segmentKeyMap = {
                critical: 'critical',
                low: 'low',
                high: 'slow'
            };

            const chips = document.querySelectorAll('.prediction-item[data-coverage-filter]');
            chips.forEach(function(chip) {
                const key = chip.getAttribute('data-coverage-filter');
                const segmentKey = segmentKeyMap[key] || key;
                const count = counts[segmentKey] || 0;
                const counter = chip.querySelector('.filter-count');
                if (counter) {
                    counter.textContent = formatChipCount(count);
                }

                if (count === 0) {
                    chip.classList.add('is-empty');
                    chip.setAttribute('aria-disabled', 'true');
                } else {
                    chip.classList.remove('is-empty');
                    chip.removeAttribute('aria-disabled');
                }
            });

            syncCoverageFilterChips();
        }

        function syncCoverageFilterChips() {
            const chips = document.querySelectorAll('.prediction-item[data-coverage-filter]');
            chips.forEach(function(chip) {
                const key = chip.getAttribute('data-coverage-filter');
                const isActive = !predictionFilter && currentFilter === key;
                if (isActive) {
                    chip.classList.add('active');
                    chip.setAttribute('aria-pressed', 'true');
                } else {
                    chip.classList.remove('active');
                    chip.setAttribute('aria-pressed', 'false');
                }
            });
        }

        function updateFloatingResetButton() {
            const resetButton = document.getElementById('globalResetButton');
            if (!resetButton) {
                return;
            }

            const hasSearch = Boolean((activeSearchContext && activeSearchContext.hasMeaning)
                || (typeof searchTerm === 'string' && searchTerm.trim() !== ''));
            const predictiveFiltersActive = predictionFilter !== null
                || ['critical', 'low', 'high', 'prediction30', 'prediction60'].includes(currentFilter)
                || criticalFilterActive
                || (advancedStockFilter && advancedStockFilter !== '');
            const dimensionFiltersActive = Boolean(selectedFamily || selectedSupplier || currentEstablishment);
            const hasAnyFilter = hasSearch || predictiveFiltersActive || dimensionFiltersActive;

            if (!hasAnyFilter) {
                resetButton.classList.remove('visible');
                resetButton.setAttribute('aria-hidden', 'true');
                resetButton.removeAttribute('data-mode');
                resetButton.textContent = 'Limpar filtros';
                return;
            }

            if (hasSearch) {
                resetButton.textContent = 'Limpar busca';
                resetButton.setAttribute('data-mode', 'search');
                resetButton.setAttribute('aria-label', 'Limpar resultados da busca');
            } else {
                resetButton.textContent = 'Limpar filtros';
                resetButton.setAttribute('data-mode', 'filters');
                resetButton.setAttribute('aria-label', 'Limpar filtros aplicados');
            }

            resetButton.classList.add('visible');
            resetButton.setAttribute('aria-hidden', 'false');
        }

        function applyAllFilters() {
            let baseData = allProductsData.slice();
            const { urgentDays, warningDays } = getPredictionSettings();

            if (selectedSearchProduct && selectedSearchProduct.code) {
                const targetCode = selectedSearchProduct.code.toString().trim().toLowerCase();
                baseData = baseData.filter(function(product) {
                    return (product.code || '').toString().trim().toLowerCase() === targetCode;
                });
            }

            if (predictionFilter === 'zero30') {
                baseData = baseData.filter(function(p) {
                    const coverage = getCoverageInfo(p);
                    if (coverage.outOfStock) {
                        return true;
                    }
                    if (coverage.daysToDepletion === null) {
                        return false;
                    }
                    return coverage.daysToDepletion <= urgentDays;
                });
            } else if (predictionFilter === 'zero60') {
                baseData = baseData.filter(function(p) {
                    const coverage = getCoverageInfo(p);
                    if (coverage.outOfStock) {
                        return false;
                    }
                    if (coverage.daysToDepletion === null) {
                        return false;
                    }
                    return coverage.daysToDepletion > urgentDays && coverage.daysToDepletion <= warningDays;
                });
            }

            if (activeSearchContext && window.searchIntelligence && typeof window.searchIntelligence.matchesProduct === 'function') {
                baseData = baseData.filter(function(product) {
                    return window.searchIntelligence.matchesProduct(product, activeSearchContext);
                });
            } else if (searchTerm) {
                baseData = baseData.filter(function(product) {
                    const codeValue = (product.code || '').toString().toLowerCase();
                    const itemValue = (product.item || '').toString().toLowerCase();
                    const supplierValue = (product.supplier || '').toString().toLowerCase();
                    const familyValue = (product.family || '').toString().toLowerCase();
                    return codeValue.includes(searchTerm)
                        || itemValue.includes(searchTerm)
                        || supplierValue.includes(searchTerm)
                        || familyValue.includes(searchTerm);
                });
            }

            if (selectedFamily) {
                baseData = baseData.filter(function(product) {
                    return product.family === selectedFamily;
                });
            }

            if (selectedSupplier) {
                baseData = baseData.filter(function(product) {
                    return product.supplier === selectedSupplier;
                });
            }

            if (currentEstablishment) {
                baseData = baseData.filter(function(product) {
                    const stock = getProductStock(product);
                    if (advancedStockFilter === 'no-stock') {
                        return stock <= 0;
                    }
                    return stock > 0;
                });
            }

            assignAbcClassification(baseData);

            const advancedSegments = computeAdvancedFilterSegments(baseData);

            if (advancedStockFilter && advancedStockFilter.startsWith('abc-')) {
                const desiredClass = advancedStockFilter.slice(4).toUpperCase();
                baseData = baseData.filter(function(product) {
                    return (product.currentAbcClass || '‚Äî') === desiredClass;
                });
            } else if (advancedStockFilter === 'no-stock') {
                baseData = baseData.filter(function(product) {
                    return getProductStock(product) <= 0;
                });
            } else if (advancedStockFilter === 'over50') {
                baseData = baseData.filter(function(product) {
                    const coverage = getCoverageInfo(product);
                    if (coverage.daysToDepletion !== null) {
                        return (coverage.daysToDepletion / 30) > 50;
                    }
                    return product.stockMonths > 50;
                });
            } else if (advancedStockFilter === 'hot-demand') {
                baseData = baseData.filter(function(product) {
                    const coverageMonths = getCoverageMonthsForProduct(product);
                    const monthlyAverage = Number.isFinite(product && product.media3M)
                        ? Number(product.media3M)
                        : 0;
                    return Number.isFinite(coverageMonths) && coverageMonths < 1.5 && monthlyAverage > 0;
                });
            } else if (advancedStockFilter === 'top-sellers-risk') {
                baseData = baseData.filter(function(product) {
                    const coverageMonths = getCoverageMonthsForProduct(product);
                    const salesFourMonths = Number.isFinite(product && product.vendas4M)
                        ? Number(product.vendas4M)
                        : 0;
                    return Number.isFinite(coverageMonths) && coverageMonths < 2 && salesFourMonths > 10000;
                });
            } else if (advancedStockFilter === 'stagnant-stock') {
                baseData = baseData.filter(function(product) {
                    const coverageMonths = getCoverageMonthsForProduct(product);
                    const monthlyAverage = Number.isFinite(product && product.media3M)
                        ? Number(product.media3M)
                        : 0;
                    return Number.isFinite(coverageMonths) && coverageMonths > 8 && monthlyAverage < 500;
                });
            }

            const coverageSegments = computeCoverageSegments(baseData);

            if (!predictionFilter) {
                switch(currentFilter) {
                    case 'critical':
                        baseData = baseData.filter(function(product) {
                            const coverageValue = getCoverageMonthsForProduct(product);
                            return Number.isFinite(coverageValue) && coverageValue < coverageSegmentThresholds.critical;
                        });
                        break;
                    case 'low':
                        baseData = baseData.filter(function(product) {
                            const coverageValue = getCoverageMonthsForProduct(product);
                            return Number.isFinite(coverageValue)
                                && coverageValue >= coverageSegmentThresholds.critical
                                && coverageValue < coverageSegmentThresholds.lowUpper;
                        });
                        break;
                    case 'high':
                        baseData = baseData.filter(function(product) {
                            const coverageValue = getCoverageMonthsForProduct(product);
                            return Number.isFinite(coverageValue) && coverageValue >= coverageSegmentThresholds.lowUpper;
                        });
                        break;
                }
            }

            if (activeRiskSelection) {
                const expectedFilter = getPredictionFilterForBucket(activeRiskSelection.bucket);
                if (expectedFilter !== predictionFilter) {
                    activeRiskSelection = null;
                    updateRiskSelectionStyles();
                }
            }

            if (activeRiskSelection && Array.isArray(activeRiskSelection.codes) && activeRiskSelection.codes.length > 0) {
                const selectedCodes = new Set(activeRiskSelection.codes);
                baseData = baseData.filter(function(product) {
                    if (!product || typeof product.code === 'undefined' || product.code === null) {
                        return false;
                    }

                    const codeValue = product.code.toString().trim().toLowerCase();
                    return codeValue !== '' && selectedCodes.has(codeValue);
                });
            }

            filteredData = baseData;
            updateAdvancedFilterChips(advancedSegments);
            updateCoverageQuickFilters(coverageSegments);
            updateParetoAnalysis();
            updateTable();
            updateSummary();
            updateGauges();
            updatePredictiveAnalysis();
            updateFloatingResetButton();
            highlightSearchResults();
        }

        function updateActiveButton(filter) {
            const filterBtns = document.querySelectorAll('.filter-btn');
            filterBtns.forEach(function(btn) {
                btn.classList.remove('active');
                if (filter && btn.dataset.filter === filter) {
                    btn.classList.add('active');
                }
            });
        }

        // === FUN√á√ïES DE AN√ÅLISE ===
        function updatePredictiveAnalysis() {
            applyPredictionLabels();

            const { urgentDays, warningDays } = getPredictionSettings();
            let urgentCount = 0;
            let warningCount = 0;
            const timelineBuckets = {
                urgent: [],
                warning: [],
                stable: [],
                unknown: []
            };

            filteredData.forEach(function(product) {
                const coverage = getCoverageInfo(product);
                const predictionInfo = getPrediction(product);
                let bucketKey = 'unknown';

                if (coverage.outOfStock) {
                    urgentCount++;
                    bucketKey = 'urgent';
                } else if (coverage.daysToDepletion === null) {
                    bucketKey = 'unknown';
                } else if (coverage.daysToDepletion <= urgentDays) {
                    urgentCount++;
                    bucketKey = 'urgent';
                } else if (coverage.daysToDepletion <= warningDays) {
                    warningCount++;
                    bucketKey = 'warning';
                } else {
                    bucketKey = 'stable';
                }

                if (!predictionInfo) {
                    return;
                }

                const estimatedDate = predictionInfo.estimatedDate ? new Date(predictionInfo.estimatedDate) : null;
                const formattedDate = estimatedDate && !Number.isNaN(estimatedDate.getTime())
                    ? estimatedDate.toLocaleDateString('pt-BR')
                    : '--';
                const coverageMonths = getCoverageMonthsForProduct(product);
                const coverageDisplay = Number.isFinite(coverageMonths) ? formatCoverageDisplay(coverageMonths) : null;
                const coverageText = coverageDisplay
                    ? (coverageDisplay.unitLabel
                        ? `${coverageDisplay.displayValue} ${coverageDisplay.unitLabel}`.trim()
                        : coverageDisplay.displayValue)
                    : null;
                const tooltipParts = [];
                if (predictionInfo.detail) {
                    tooltipParts.push(predictionInfo.detail);
                } else if (predictionInfo.fullText) {
                    tooltipParts.push(predictionInfo.fullText);
                }
                if (coverageText) {
                    tooltipParts.push(`Cobertura atual: ${coverageText}`);
                }
                if (Number.isFinite(coverage.daysToDepletion)) {
                    tooltipParts.push(`Dias at√© ruptura: ${Math.round(coverage.daysToDepletion)}`);
                }
                if (formattedDate && formattedDate !== '--') {
                    tooltipParts.push(`Ruptura estimada: ${formattedDate}`);
                }

                const entry = {
                    product: product,
                    prediction: predictionInfo,
                    formattedDate: formattedDate,
                    tooltip: tooltipParts.join(' ‚Ä¢ '),
                    coverageMonths: Number.isFinite(coverageMonths) ? coverageMonths : null,
                    coverageDisplay: coverageDisplay,
                    coverageText: coverageText
                };

                if (bucketKey === 'urgent') {
                    timelineBuckets.urgent.push(entry);
                } else if (bucketKey === 'warning') {
                    timelineBuckets.warning.push(entry);
                } else if (bucketKey === 'stable') {
                    timelineBuckets.stable.push(entry);
                } else {
                    timelineBuckets.unknown.push(entry);
                }
            });

            const totalItems = filteredData.length;
            const stableCount = timelineBuckets.stable.length;
            const unknownCount = timelineBuckets.unknown.length;

            const formatPercentLabel = function(count) {
                if (!Number.isFinite(count) || count <= 0 || totalItems <= 0) {
                    return null;
                }

                const percentValue = (count / totalItems) * 100;
                const label = percentValue >= 10 ? percentValue.toFixed(0) : percentValue.toFixed(1);
                return { value: percentValue, label: `${label}%` };
            };

            const buildRiskSegments = function(entries) {
                if (!Array.isArray(entries) || entries.length === 0) {
                    return [];
                }

                const extractSegmentProductNames = function(segmentEntries) {
                    if (!Array.isArray(segmentEntries)) {
                        return [];
                    }

                    return segmentEntries.map(function(entry) {
                        const product = entry && entry.product ? entry.product : null;
                        if (!product) {
                            return null;
                        }

                        const rawName = typeof product.item === 'string' && product.item.trim() !== ''
                            ? product.item.trim()
                            : null;

                        if (rawName) {
                            return rawName;
                        }

                        if (typeof product.code !== 'undefined' && product.code !== null) {
                            const codeValue = product.code.toString().trim();
                            if (codeValue !== '') {
                                return `C√≥digo ${codeValue}`;
                            }
                        }

                        return null;
                    }).filter(function(name) {
                        return typeof name === 'string' && name.trim() !== '';
                    });
                };

                const buildSegmentProductTooltip = function(segmentEntries) {
                    const names = extractSegmentProductNames(segmentEntries);
                    if (names.length === 0) {
                        return '';
                    }

                    const maxLength = 140;
                    const selected = [];
                    let currentLength = 0;
                    let truncated = false;

                    names.forEach(function(name) {
                        if (truncated) {
                            return;
                        }

                        const normalized = name.trim();
                        if (normalized === '') {
                            return;
                        }

                        const prefix = selected.length > 0 ? ', ' : '';
                        const additionLength = prefix.length + normalized.length;

                        if ((currentLength + additionLength) > maxLength) {
                            if (selected.length === 0) {
                                selected.push(normalized);
                                currentLength += additionLength;
                            }
                            truncated = true;
                            return;
                        }

                        selected.push(normalized);
                        currentLength += additionLength;
                    });

                    if (selected.length === 0) {
                        selected.push(names[0]);
                        truncated = names.length > 1;
                    }

                    let text = selected.join(', ');
                    if (truncated || selected.length < names.length) {
                        text = text ? `${text}, (...)` : '(...)';
                    }

                    return text;
                };

                const aggregation = entries.reduce(function(acc, entry) {
                    const product = entry && entry.product ? entry.product : null;
                    const family = product && typeof product.family === 'string' && product.family.trim() !== ''
                        ? product.family.trim()
                        : null;
                    const fallback = product && typeof product.supplier === 'string' && product.supplier.trim() !== ''
                        ? product.supplier.trim()
                        : 'Sem fam√≠lia';
                    const key = (family || fallback || 'Sem fam√≠lia').toString();
                    if (!acc[key]) {
                        acc[key] = {
                            label: key,
                            count: 0,
                            entries: [],
                            codes: new Set(),
                            normalizedCodes: new Set(),
                            matchType: family ? 'family' : 'supplier'
                        };
                    }

                    const group = acc[key];
                    group.count += 1;
                    group.entries.push(entry);
                    if (family) {
                        group.matchType = 'family';
                    }

                    const productCode = product && typeof product.code !== 'undefined' && product.code !== null
                        ? product.code.toString().trim()
                        : '';
                    if (productCode !== '') {
                        group.codes.add(productCode);
                        group.normalizedCodes.add(productCode.toLowerCase());
                    }

                    return acc;
                }, {});

                let segments = Object.keys(aggregation).map(function(label) {
                    const group = aggregation[label];
                    return {
                        label: group.label,
                        count: group.count,
                        matchType: group.matchType,
                        codes: Array.from(group.normalizedCodes),
                        rawCodes: Array.from(group.codes),
                        entries: group.entries.slice(),
                        normalizedLabel: group.label.toString().trim().toLowerCase()
                    };
                });

                segments.sort(function(a, b) {
                    if (b.count === a.count) {
                        return a.label.localeCompare(b.label);
                    }
                    return b.count - a.count;
                });

                if (segments.length > riskChartMaxSegments) {
                    const head = segments.slice(0, riskChartMaxSegments - 1);
                    const remainder = segments.slice(riskChartMaxSegments - 1);
                    const aggregated = remainder.reduce(function(acc, segment) {
                        if (!segment) {
                            return acc;
                        }

                        const count = Number.isFinite(segment.count) ? segment.count : 0;
                        acc.count += count;

                        if (Array.isArray(segment.entries)) {
                            acc.entries = acc.entries.concat(segment.entries);
                        }

                        if (Array.isArray(segment.codes)) {
                            segment.codes.forEach(function(code) {
                                if (code) {
                                    acc.codes.add(code);
                                }
                            });
                        }

                        if (Array.isArray(segment.rawCodes)) {
                            segment.rawCodes.forEach(function(code) {
                                if (code) {
                                    acc.rawCodes.add(code);
                                }
                            });
                        }

                        return acc;
                    }, {
                        count: 0,
                        entries: [],
                        codes: new Set(),
                        rawCodes: new Set()
                    });

                    head.push({
                        label: 'Outros',
                        count: aggregated.count,
                        entries: aggregated.entries,
                        codes: Array.from(aggregated.codes),
                        rawCodes: Array.from(aggregated.rawCodes),
                        matchType: 'mixed',
                        normalizedLabel: 'outros'
                    });

                    segments = head;
                }

                segments.forEach(function(segment) {
                    segment.productTooltip = buildSegmentProductTooltip(segment.entries);
                });

                return segments;
            };

            const updateRiskCard = function(config) {
                const valueElement = document.getElementById(config.valueId);
                const detailElement = document.getElementById(config.detailId);
                const legendElement = document.getElementById(config.legendId);
                const emptyElement = document.getElementById(config.emptyId);
                const canvas = document.getElementById(config.chartId);
                const percentElement = config.percentId
                    ? document.getElementById(config.percentId)
                    : null;
                const entries = Array.isArray(config.entries) ? config.entries : [];
                const percentData = formatPercentLabel(config.count);
                const percentValue = percentData ? percentData.value : 0;
                const percentLabel = percentData ? percentData.label : null;

                if (valueElement) {
                    valueElement.textContent = totalItems > 0 ? config.count : '--';
                }

                if (percentElement) {
                    percentElement.textContent = percentLabel || '--%';
                }

                if (detailElement) {
                    const detailText = typeof config.detailBuilder === 'function'
                        ? config.detailBuilder(config.count, percentLabel, totalItems, unknownCount)
                        : '';
                    detailElement.textContent = detailText || '';
                }

                if (canvas && typeof config.ariaLabel === 'function') {
                    canvas.setAttribute('aria-label', config.ariaLabel(config.count, percentValue, totalItems));
                }

                if (!legendElement || !canvas) {
                    return;
                }

                if (!Array.isArray(entries) || entries.length === 0) {
                    legendElement.innerHTML = '';
                    if (emptyElement) {
                        emptyElement.hidden = false;
                    }
                    if (riskChartInstances[config.chartId]) {
                        const chartInstance = riskChartInstances[config.chartId];
                        if (chartInstance && chartInstance.$riskTooltipLeaveHandler && chartInstance.canvas) {
                            chartInstance.canvas.removeEventListener('mouseleave', chartInstance.$riskTooltipLeaveHandler);
                        }

                        if (activeRiskChartTooltip && activeRiskChartTooltip.chart === chartInstance) {
                            hideRiskChartTooltip();
                        }

                        chartInstance.destroy();
                        delete riskChartInstances[config.chartId];
                    }
                    return;
                }

                if (emptyElement) {
                    emptyElement.hidden = true;
                }

                const segments = buildRiskSegments(entries);
                const selection = activeRiskSelection && activeRiskSelection.bucket === config.bucket
                    ? activeRiskSelection
                    : null;
                const totalSegmentsCount = segments.reduce(function(sum, segment) {
                    return sum + segment.count;
                }, 0);
                const palette = Array.isArray(config.palette) && config.palette.length > 0
                    ? config.palette
                    : familyAccentPalette;
                const colors = segments.map(function(segment, index) {
                    const baseColor = palette[index % palette.length] || familyAccentFallback;
                    const lightenStep = Math.min(0.18, index * 0.05);
                    const adjusted = shiftHexColor(baseColor, lightenStep);
                    return adjusted || baseColor;
                });

                if (typeof Chart !== 'undefined') {
                    const datasetData = segments.map(function(segment) { return segment.count; });
                    const datasetColors = colors.slice();
                    const labels = segments.map(function(segment) { return segment.label; });
                    let chart = riskChartInstances[config.chartId];

                    if (chart) {
                        if (chart.$riskTooltipLeaveHandler && chart.canvas) {
                            chart.canvas.removeEventListener('mouseleave', chart.$riskTooltipLeaveHandler);
                        }
                        if (chart.$riskCanvasClickHandler && chart.canvas) {
                            chart.canvas.removeEventListener('click', chart.$riskCanvasClickHandler);
                        }
                        chart.destroy();
                        delete riskChartInstances[config.chartId];
                        chart = null;
                    }

                    const context = canvas.getContext('2d');
                    let chartInstance;
                    const chartConfig = {
                        type: 'doughnut',
                        data: {
                            labels: labels,
                            datasets: [{
                                data: datasetData,
                                backgroundColor: datasetColors,
                                hoverBackgroundColor: datasetColors,
                                borderColor: '#ffffff',
                                hoverBorderColor: '#ffffff',
                                borderWidth: 2,
                                hoverOffset: 6
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            cutout: '70%',
                            animation: {
                                animateRotate: true,
                                duration: 650
                            },
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    enabled: false,
                                    external: renderRiskChartTooltip
                                }
                            }
                        },
                        onHover: function(event) {
                            const nativeEvent = event && event.native ? event.native : event;
                            const canvasElement = nativeEvent && nativeEvent.target ? nativeEvent.target : canvas;
                            if (canvasElement && typeof canvasElement.style !== 'undefined') {
                                canvasElement.style.cursor = 'default';
                            }
                        }
                    };

                    chartInstance = new Chart(context, chartConfig);
                    chart = chartInstance;
                    riskChartInstances[config.chartId] = chartInstance;
                    chartInstance.$riskTooltipLeaveHandler = function() {
                        if (activeRiskChartTooltip && activeRiskChartTooltip.chart === chart) {
                            hideRiskChartTooltip();
                        }
                    };
                    if (chartInstance.canvas) {
                        chartInstance.canvas.addEventListener('mouseleave', chartInstance.$riskTooltipLeaveHandler);
                    }

                    if (selection && Number.isInteger(selection.index)) {
                        chartInstance.setActiveElements([{ datasetIndex: 0, index: selection.index }]);
                    } else {
                        chartInstance.setActiveElements([]);
                    }

                    chartInstance.$riskSegments = segments;
                    chartInstance.$riskConfig = config;
                    chartInstance.$riskTotalSegmentsCount = totalSegmentsCount;
                    chartInstance.update();
                }

                const legendHtml = segments.map(function(segment, index) {
                    const percent = totalSegmentsCount > 0
                        ? (segment.count / totalSegmentsCount) * 100
                        : 0;
                    const percentText = percent >= 10 ? percent.toFixed(0) : percent.toFixed(1);
                    const itemLabel = segment.count === 1 ? 'item' : 'itens';
                    const color = colors[index];
                    const progressWidth = percent > 0 ? Math.max(percent, 6) : 0;
                    const isActive = selection
                        && selection.chartId === config.chartId
                        && Number.isInteger(selection.index)
                        && selection.index === index;
                    const tooltipText = typeof segment.productTooltip === 'string'
                        ? segment.productTooltip
                        : '';
                    const classes = ['prediction-legend-item'];
                    if (isActive) {
                        classes.push('is-active');
                    }
                    if (tooltipText) {
                        classes.push('has-tooltip');
                    }
                    const tooltipAttr = tooltipText
                        ? ` data-tooltip="${escapeTooltip(tooltipText)}"`
                        : '';

                    return `<div class="${classes.join(' ')}" data-chart-id="${escapeTooltip(config.chartId)}" data-segment-index="${index}" role="listitem"${tooltipAttr}>`
                        + `<span class="prediction-legend-dot" style="background:${color}"></span>`
                        + `<div class="prediction-legend-meta">`
                        + `<strong>${escapeTooltip(segment.label)}</strong>`
                        + `<div class="prediction-legend-progress" aria-hidden="true">`
                        + `<span class="prediction-legend-progress-bar" style="width:${progressWidth}%; background:${color};"></span>`
                        + `</div>`
                        + `<span class="prediction-legend-stat">${segment.count} ${itemLabel} ‚Ä¢ ${percentText}%</span>`
                        + `</div>`
                        + `</div>`;
                }).join('');

                legendElement.innerHTML = legendHtml;
                setupRiskLegendInteractions(legendElement);
                initializeTooltips(legendElement);
            };

            updateRiskCard({
                chartId: 'urgentRiskChart',
                legendId: 'urgentRiskLegend',
                emptyId: 'urgentRiskEmpty',
                valueId: 'urgentRiskValue',
                percentId: 'urgentRiskPercent',
                detailId: 'urgentRiskDetail',
                entries: timelineBuckets.urgent,
                count: urgentCount,
                bucket: 'urgent',
                palette: ['#7f1d1d', '#b91c1c', '#dc2626', '#ef4444', '#f87171'],
                ariaLabel: function(count, percent) {
                    if (totalItems <= 0) {
                        return 'Sem dados de ruptura urgente nos filtros atuais';
                    }

                    const labelPercent = percent ? `${percent.toFixed(1)}%` : '0%';
                    return `${count} de ${totalItems} itens com ruptura urgente (${labelPercent})`;
                },
                detailBuilder: function(count, percentLabel) {
                    if (totalItems <= 0) {
                        return '';
                    }

                    if (count <= 0) {
                        return 'Nenhum item cr√≠tico nos filtros atuais.';
                    }

                    return percentLabel ? `${percentLabel} dos itens filtrados.` : '';
                }
            });

            updateRiskCard({
                chartId: 'warningRiskChart',
                legendId: 'warningRiskLegend',
                emptyId: 'warningRiskEmpty',
                valueId: 'warningRiskValue',
                percentId: 'warningRiskPercent',
                detailId: 'warningRiskDetail',
                entries: timelineBuckets.warning,
                count: warningCount,
                bucket: 'warning',
                palette: ['#92400e', '#b45309', '#d97706', '#f59e0b', '#fbbf24'],
                ariaLabel: function(count, percent) {
                    if (totalItems <= 0) {
                        return 'Sem dados de ruptura em aten√ß√£o nos filtros atuais';
                    }

                    const labelPercent = percent ? `${percent.toFixed(1)}%` : '0%';
                    return `${count} de ${totalItems} itens em aten√ß√£o (${labelPercent})`;
                },
                detailBuilder: function(count, percentLabel) {
                    if (totalItems <= 0) {
                        return '';
                    }

                    if (count <= 0) {
                        return 'Nenhum item em aten√ß√£o neste momento.';
                    }

                    return percentLabel ? `${percentLabel} dos itens avaliados.` : '';
                }
            });

            updateRiskCard({
                chartId: 'comfortableRiskChart',
                legendId: 'comfortableRiskLegend',
                emptyId: 'comfortableRiskEmpty',
                valueId: 'comfortableRiskValue',
                percentId: 'comfortableRiskPercent',
                detailId: 'comfortableRiskDetail',
                entries: timelineBuckets.stable,
                count: stableCount,
                bucket: 'comfortable',
                palette: ['#0b4f3a', '#0e6f4b', '#128f5c', '#16af6d', '#1ac07a'],
                ariaLabel: function(count, percent) {
                    if (totalItems <= 0) {
                        return 'Sem dados de cobertura confort√°vel nos filtros atuais';
                    }

                    const labelPercent = percent ? `${percent.toFixed(1)}%` : '0%';
                    return `${count} de ${totalItems} itens com cobertura confort√°vel (${labelPercent})`;
                },
                detailBuilder: function(count, percentLabel, total, unknown) {
                    if (total <= 0) {
                        return '';
                    }

                    if (count <= 0) {
                        if (unknown > 0) {
                            const label = unknown === 1 ? 'item' : 'itens';
                            return `${unknown} ${label} sem dados suficientes para previs√£o.`;
                        }

                        return 'Nenhum item com cobertura confort√°vel.';
                    }

                    return percentLabel ? `${percentLabel} dos itens analisados.` : '';
                }
            });

            const sortByDays = function(list) {
                return list.sort(function(a, b) {
                    const daysA = Number.isFinite(a && a.prediction && a.prediction.daysToDepletion)
                        ? a.prediction.daysToDepletion
                        : Number.MAX_SAFE_INTEGER;
                    const daysB = Number.isFinite(b && b.prediction && b.prediction.daysToDepletion)
                        ? b.prediction.daysToDepletion
                        : Number.MAX_SAFE_INTEGER;
                    return daysA - daysB;
                });
            };

            sortByDays(timelineBuckets.urgent);
            sortByDays(timelineBuckets.warning);
            sortByDays(timelineBuckets.stable);

            renderPredictionTimeline(timelineBuckets, urgentDays, warningDays);
        }

        function buildTimelineProductChip(product, fallbackName) {
            const rawName = fallbackName && fallbackName.toString().trim() !== ''
                ? fallbackName.toString()
                : (product && (product.item || product.code))
                    ? (product.item || product.code)
                    : 'Produto';
            const displayName = escapeTooltip(rawName);
            const codeValue = product && product.code ? product.code.toString().trim() : '';

            if (codeValue !== '') {
                const safeCode = escapeTooltip(codeValue);
                const actionLabel = escapeTooltip(`Abrir hist√≥rico do produto ${rawName}`);
                return `<button type="button" class="product-chip timeline-product-chip" data-code="${safeCode}" aria-label="${actionLabel}" onclick="openProductHistoryFromElement(this)" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();openProductHistoryFromElement(this);}">${displayName}</button>`;
            }

            return `<span class="product-chip product-chip-static timeline-product-chip">${displayName}</span>`;
        }

        function toggleFamilyFilterSelection(family) {
            const rawFamily = typeof family === 'string' ? family.trim() : '';
            const dropdown = document.getElementById('familyFilter');
            const currentNormalized = selectedFamily ? selectedFamily.toString().trim().toLowerCase() : '';
            const candidateNormalized = rawFamily.toLowerCase();
            const shouldReset = !rawFamily || currentNormalized === candidateNormalized;

            if (shouldReset) {
                selectedFamily = null;
                if (dropdown) {
                    dropdown.value = '';
                }
            } else {
                selectedFamily = rawFamily;
                if (dropdown) {
                    const matchingOption = Array.from(dropdown.options || []).find(function(option) {
                        return option.value.toString().trim().toLowerCase() === candidateNormalized;
                    });

                    if (matchingOption) {
                        dropdown.value = matchingOption.value;
                    } else {
                        const option = document.createElement('option');
                        option.value = rawFamily;
                        option.textContent = rawFamily;
                        dropdown.appendChild(option);
                        dropdown.value = rawFamily;
                    }
                }
            }

            refreshFamilyChipSelection();
            criticalFilterActive = false;
            applyAllFilters();
        }

        function onFamilyChipClick(event) {
            const chip = event.currentTarget;
            if (!chip) {
                return;
            }

            const family = chip.dataset.family || '';
            if (!family) {
                return;
            }

            event.preventDefault();
            event.stopPropagation();
            toggleFamilyFilterSelection(family);
        }

        function onFamilyChipKeydown(event) {
            if (event.key !== 'Enter' && event.key !== ' ') {
                return;
            }

            const chip = event.currentTarget;
            if (!chip) {
                return;
            }

            event.preventDefault();
            const family = chip.dataset.family || '';
            if (!family) {
                return;
            }

            toggleFamilyFilterSelection(family);
        }

        function refreshFamilyChipSelection(scope) {
            const root = scope || document;
            const chips = root.querySelectorAll('.js-family-chip');
            chips.forEach(function(chip) {
                const family = chip.dataset.family || '';
                if (!family) {
                    chip.classList.remove('is-selected');
                    chip.removeAttribute('aria-pressed');
                    return;
                }

                const isSelected = !!selectedFamily && family === selectedFamily;
                if (isSelected) {
                    chip.classList.add('is-selected');
                    chip.setAttribute('aria-pressed', 'true');
                } else {
                    chip.classList.remove('is-selected');
                    chip.setAttribute('aria-pressed', 'false');
                }
            });
        }

        function setupFamilyChipInteractions(root) {
            const scope = root || document;
            const chips = scope.querySelectorAll('.js-family-chip');

            chips.forEach(function(chip) {
                chip.removeEventListener('click', onFamilyChipClick);
                chip.removeEventListener('keydown', onFamilyChipKeydown);
                chip.addEventListener('click', onFamilyChipClick);
                chip.addEventListener('keydown', onFamilyChipKeydown);
            });

            refreshFamilyChipSelection(scope);
        }

        function renderPredictionTimeline(buckets, urgentDays, warningDays) {
            const container = document.getElementById('predictionTimeline');
            if (!container) {
                return;
            }

            const maxPreviewItems = 8;
            const urgentEntries = Array.isArray(buckets && buckets.urgent) ? buckets.urgent : [];
            const warningEntries = Array.isArray(buckets && buckets.warning) ? buckets.warning : [];
            const stableEntries = Array.isArray(buckets && buckets.stable) ? buckets.stable : [];
            const unknownEntries = Array.isArray(buckets && buckets.unknown) ? buckets.unknown : [];
            const urgentCount = urgentEntries.length;
            const warningCount = warningEntries.length;
            const formatDaysText = function(value) {
                if (!Number.isFinite(value)) {
                    return '--';
                }

                const rounded = Math.round(value);
                return rounded === 1 ? '1 dia' : `${rounded} dias`;
            };

            const urgentLimitText = Number.isFinite(urgentDays)
                ? `Cobertura ‚â§ ${formatDaysText(urgentDays)}`
                : 'Cobertura urgente';
            const warningStart = Number.isFinite(urgentDays) ? Math.round(urgentDays) + 1 : null;
            const warningSubtitle = Number.isFinite(warningDays)
                ? (warningStart !== null
                    ? `Cobertura entre ${warningStart} e ${Math.round(warningDays)} dias`
                    : `Cobertura ‚â§ ${formatDaysText(warningDays)}`)
                : 'Cobertura em aten√ß√£o';

            let comfortableSubtitle = 'Acima dos limites configurados';
            if (Number.isFinite(warningDays)) {
                const comfortableCoverage = formatCoverageDisplay(warningDays / 30);
                const coverageLabel = comfortableCoverage && comfortableCoverage.displayValue !== '--'
                    ? (comfortableCoverage.unitLabel
                        ? `${comfortableCoverage.displayValue} ${comfortableCoverage.unitLabel}`.trim()
                        : comfortableCoverage.displayValue)
                    : '';
                const daysLabel = formatDaysText(warningDays);
                comfortableSubtitle = coverageLabel
                    ? `Cobertura superior a ${daysLabel} (${coverageLabel})`
                    : `Cobertura superior a ${daysLabel}`;
            }

            const highlights = [];
            const withDays = ['urgent', 'warning'].reduce(function(acc, key) {
                const entries = key === 'urgent' ? urgentEntries : warningEntries;
                entries.forEach(function(entry) {
                    const days = entry && entry.prediction ? entry.prediction.daysToDepletion : null;
                    if (Number.isFinite(days)) {
                        acc.push({ entry: entry, bucket: key });
                    }
                });
                return acc;
            }, []);

            withDays.sort(function(a, b) {
                return a.entry.prediction.daysToDepletion - b.entry.prediction.daysToDepletion;
            });

            if (withDays.length > 0) {
                const nextRupture = withDays[0];
                const productName = nextRupture.entry.product && (nextRupture.entry.product.item || nextRupture.entry.product.code)
                    ? (nextRupture.entry.product.item || nextRupture.entry.product.code)
                    : 'Produto';
                const daysText = formatDaysText(nextRupture.entry.prediction.daysToDepletion);
                const dateText = nextRupture.entry.formattedDate && nextRupture.entry.formattedDate !== '--'
                    ? nextRupture.entry.formattedDate
                    : '';
                const detailParts = [`Estimativa em ${daysText}`];
                if (dateText) {
                    detailParts.push(dateText);
                }
                highlights.push({
                    label: 'Pr√≥xima ruptura prevista',
                    title: productName,
                    titleHtml: buildTimelineProductChip(nextRupture.entry.product, productName),
                    detail: detailParts.join(' ‚Ä¢ '),
                    action: nextRupture.bucket === 'urgent'
                        ? { handler: 'filterZeroIn30()', label: 'Ver cr√≠ticos' }
                        : { handler: 'filterZeroIn60()', label: 'Ver aten√ß√£o' }
                });
            }

            const slowCandidates = stableEntries.filter(function(entry) {
                return Number.isFinite(entry && entry.coverageMonths)
                    && entry.coverageMonths >= coverageSegmentThresholds.lowUpper;
            });

            if (slowCandidates.length > 0) {
                const sortedSlow = slowCandidates.slice().sort(function(a, b) {
                    return (b.coverageMonths || 0) - (a.coverageMonths || 0);
                });
                const topSlow = sortedSlow.slice(0, 3);
                const names = topSlow.map(function(entry) {
                    const product = entry && entry.product;
                    if (!product) {
                        return 'Produto';
                    }
                    return product.item || product.code || 'Produto';
                });
                const coverageTexts = topSlow.map(function(entry) {
                    return entry && entry.coverageText ? entry.coverageText : '--';
                });
                const remainingSlow = slowCandidates.length - topSlow.length;
                const coverageDetail = remainingSlow > 0
                    ? `${coverageTexts.join(' ‚Ä¢ ')} (+${remainingSlow} ${remainingSlow === 1 ? 'item' : 'itens'})`
                    : coverageTexts.join(' ‚Ä¢ ');
                const namesHtml = topSlow.map(function(entry, index) {
                    const product = entry && entry.product ? entry.product : null;
                    const displayName = names[index] || (product && (product.item || product.code)) || 'Produto';
                    return buildTimelineProductChip(product, displayName);
                }).join(' ');

                highlights.push({
                    label: 'Maiores coberturas',
                    title: names.join(', '),
                    titleHtml: namesHtml,
                    detail: `Coberturas: ${coverageDetail}`,
                    action: { handler: 'filterHighStock()', label: 'Ver slow moving' }
                });
            }

            if (highlights.length === 0) {
                highlights.push({
                    label: 'Tudo em dia',
                    title: 'Nenhum risco de ruptura detectado',
                    detail: 'Os filtros atuais apresentam cobertura confort√°vel para todos os itens monitorados.',
                    action: null
                });
            }

            const highlightsHtml = `<div class="timeline-highlights">${highlights.map(function(card) {
                const actionHtml = card.action
                    ? `<button type="button" class="highlight-action" onclick="${card.action.handler}">${card.action.label} ‚Üí</button>`
                    : '';
                const detailHtml = card.detail ? `<span>${escapeTooltip(card.detail)}</span>` : '';
                const titleContent = card.titleHtml
                    ? card.titleHtml
                    : escapeTooltip(card.title || '');

                return `<div class="timeline-highlight">`
                    + `<span class="highlight-label">${escapeTooltip(card.label)}</span>`
                    + `<strong>${titleContent}</strong>`
                    + `${detailHtml}`
                    + `${actionHtml}`
                    + `</div>`;
            }).join('')}</div>`;

            const severityStyles = {
                urgent: {
                    badgeLabel: 'Urgente',
                    badgeClass: 'timeline-badge-critical',
                    itemClass: 'timeline-item-critical',
                    accent: '#d32f2f',
                    ariaPrefix: 'Ruptura urgente'
                },
                warning: {
                    badgeLabel: 'Em aten√ß√£o',
                    badgeClass: 'timeline-badge-warning',
                    itemClass: 'timeline-item-warning',
                    accent: '#f59e0b',
                    ariaPrefix: 'Ruptura em aten√ß√£o'
                }
            };

            const combinedEntries = [];
            urgentEntries.forEach(function(entry) {
                combinedEntries.push({ entry: entry, severity: 'urgent' });
            });
            warningEntries.forEach(function(entry) {
                combinedEntries.push({ entry: entry, severity: 'warning' });
            });

            combinedEntries.sort(function(a, b) {
                const aDays = a.entry && a.entry.prediction && Number.isFinite(a.entry.prediction.daysToDepletion)
                    ? a.entry.prediction.daysToDepletion
                    : Number.POSITIVE_INFINITY;
                const bDays = b.entry && b.entry.prediction && Number.isFinite(b.entry.prediction.daysToDepletion)
                    ? b.entry.prediction.daysToDepletion
                    : Number.POSITIVE_INFINITY;

                if (aDays !== bDays) {
                    return aDays - bDays;
                }

                if (a.severity === b.severity) {
                    const aName = a.entry && a.entry.product && (a.entry.product.item || a.entry.product.code) || '';
                    const bName = b.entry && b.entry.product && (b.entry.product.item || b.entry.product.code) || '';
                    return aName.localeCompare(bName);
                }

                return a.severity === 'urgent' ? -1 : 1;
            });

            const buildCombinedList = function(entries) {
                if (!Array.isArray(entries) || entries.length === 0) {
                    return '';
                }

                const shouldCollapse = entries.length > maxPreviewItems;
                const listClass = shouldCollapse ? 'timeline-list' : 'timeline-list is-expanded';

                const itemsHtml = entries.map(function(item) {
                    const entry = item.entry;
                    const product = entry && entry.product ? entry.product : null;
                    const severity = item.severity === 'urgent' || item.severity === 'warning'
                        ? item.severity
                        : 'warning';
                    const severityConfig = severityStyles[severity];
                    const rawProductName = product && product.item
                        ? product.item
                        : (product && product.code ? product.code : 'Produto');
                    const productChip = buildTimelineProductChip(product, rawProductName);
                    const productCode = product && product.code ? escapeTooltip(product.code) : '';
                    const label = entry && entry.prediction && entry.prediction.label ? escapeTooltip(entry.prediction.label) : '';
                    const tooltipText = entry && entry.tooltip ? escapeTooltip(entry.tooltip) : '';
                    const dateText = entry && entry.formattedDate && entry.formattedDate !== '--'
                        ? escapeTooltip(entry.formattedDate)
                        : '';
                    const daysValue = entry && entry.prediction && Number.isFinite(entry.prediction.daysToDepletion)
                        ? entry.prediction.daysToDepletion
                        : null;
                    const metaChips = [];
                    if (Number.isFinite(daysValue)) {
                        metaChips.push(`<span>${formatDaysText(daysValue)}</span>`);
                    }
                    if (dateText) {
                        metaChips.push(`<span>${dateText}</span>`);
                    }
                    if (entry && entry.coverageText) {
                        metaChips.push(`<span class="timeline-meta-coverage">${escapeTooltip(entry.coverageText)}</span>`);
                    }

                    const tooltipAttr = tooltipText ? ` data-tooltip="${tooltipText}"` : '';
                    const ariaParts = [severityConfig.ariaPrefix, rawProductName];
                    if (label) {
                        ariaParts.push(label);
                    }
                    if (Number.isFinite(daysValue)) {
                        ariaParts.push(formatDaysText(daysValue));
                    }
                    if (entry && entry.coverageText) {
                        ariaParts.push(entry.coverageText);
                    }
                    if (dateText) {
                        ariaParts.push(`Data ${dateText}`);
                    }
                    const ariaLabel = escapeTooltip(ariaParts.join(' ‚Ä¢ '));
                    const codeLabel = productCode ? ` <span class="timeline-item-code">(${productCode})</span>` : '';
                    const metaHtml = metaChips.length > 0
                        ? `<div class="timeline-item-meta">${metaChips.join('')}</div>`
                        : '';
                    const noteHtml = label ? `<div class="timeline-item-note">${label}</div>` : '';

                    return `<li class="timeline-item has-tooltip ${severityConfig.itemClass}" tabindex="0" aria-label="${ariaLabel}"${tooltipAttr}>`
                        + `<div class="timeline-item-title">`
                        + `<span class="timeline-badge ${severityConfig.badgeClass}">${severityConfig.badgeLabel}</span>`
                        + `${productChip}${codeLabel}`
                        + `</div>`
                        + `${metaHtml}`
                        + `${noteHtml}`
                        + `</li>`;
                }).join('');

                return `<ul class="${listClass}" data-list="upcoming" data-count="${entries.length}">${itemsHtml}</ul>`;
            };

            const combinedListHtml = buildCombinedList(combinedEntries);
            const toggleButton = combinedEntries.length > maxPreviewItems
                ? `<div class="timeline-toggle-wrapper"><button type="button" class="timeline-toggle" data-target="upcoming" data-total="${combinedEntries.length}" aria-expanded="false" aria-label="Ver todos os ${combinedEntries.length} itens previstos">Ver todos</button></div>`
                : '';

            const listContent = combinedListHtml || '<div class="timeline-empty">Nenhuma previs√£o cr√≠tica ou em aten√ß√£o nos filtros atuais.</div>';
            const urgentLabel = urgentCount === 1 ? '1 urgente' : `${urgentCount} urgentes`;
            const warningLabel = warningCount === 1 ? '1 em aten√ß√£o' : `${warningCount} em aten√ß√£o`;
            const hasAnyItems = combinedEntries.length > 0;

            const boardWrapper = `<div class="timeline-board">`
                + `<div class="timeline-card timeline-card-combined">`
                + `<div class="timeline-card-header">`
                + `<div class="lane-title">`
                + `<strong>Pr√≥ximas rupturas</strong>`
                + `<span>Urgente: ${urgentLimitText}. Aten√ß√£o: ${warningSubtitle}.</span>`
                + `</div>`
                + `<div class="lane-meta timeline-card-stats">`
                + `<span class="timeline-card-pill pill-critical">${urgentLabel}</span>`
                + `<span class="timeline-card-pill pill-warning">${warningLabel}</span>`
                + `</div>`
                + `</div>`
                + `${listContent}`
                + `${toggleButton}`
                + `</div>`
                + `</div>`;

            const unknownCount = unknownEntries.length;
            const unknownNote = unknownCount > 0
                ? `<div class="timeline-note">‚ö†Ô∏è ${unknownCount} ${unknownCount === 1 ? 'item' : 'itens'} sem previs√£o calculada ‚Äî revise hist√≥rico de vendas para gerar uma estimativa.</div>`
                : '';

            const shouldCompact = !hasAnyItems && unknownCount === 0;
            if (shouldCompact) {
                container.classList.add('is-empty-state');
            } else {
                container.classList.remove('is-empty-state');
            }

            container.innerHTML = `${highlightsHtml}${boardWrapper}${unknownNote}`;
            initializePredictionTimelineInteractions(container);
            initializeTooltips(container);
        }

        function initializePredictionTimelineInteractions(scope) {
            const root = scope || document;
            const toggles = root.querySelectorAll('.timeline-toggle');

            toggles.forEach(function(button) {
                button.addEventListener('click', function() {
                    const target = button.dataset.target;
                    if (!target) {
                        return;
                    }

                    const list = root.querySelector(`.timeline-list[data-list="${target}"]`);
                    if (!list) {
                        return;
                    }

                    const isExpanded = list.classList.toggle('is-expanded');
                    button.setAttribute('aria-expanded', isExpanded.toString());
                    const total = button.dataset.total || list.dataset.count || list.childElementCount;
                    button.textContent = isExpanded ? 'Mostrar menos' : 'Ver todos';
                    if (isExpanded) {
                        button.setAttribute('aria-label', 'Mostrar menos itens previstos');
                    } else {
                        button.setAttribute('aria-label', `Ver todos os ${total} itens previstos`);
                    }
                });
            });

            setupFamilyChipInteractions(root);
        }

        function showToast(message, type) {
            const container = document.getElementById('toastContainer');
            if (!container || !message) {
                return;
            }

            const toast = document.createElement('div');
            const normalizedType = type || 'info';
            const typeClass = normalizedType === 'success'
                ? ' toast-success'
                : normalizedType === 'warning'
                    ? ' toast-warning'
                    : normalizedType === 'error'
                        ? ' toast-error'
                        : '';

            toast.className = `toast${typeClass}`;
            toast.setAttribute('role', 'status');
            toast.setAttribute('aria-live', 'polite');
            toast.textContent = message;

            container.appendChild(toast);

            setTimeout(function() {
                toast.style.animation = 'toast-out 0.25s ease forwards';
                setTimeout(function() {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 260);
            }, 3200);
        }

        function openPredictionSettings() {
            const modal = document.getElementById('predictionSettingsModal');
            if (!modal) {
                return;
            }

            const { urgentDays, warningDays } = getPredictionSettings();
            const urgentInput = document.getElementById('urgentDaysInput');
            const warningInput = document.getElementById('warningDaysInput');

            if (urgentInput) {
                urgentInput.value = Number.isFinite(urgentDays) ? Math.round(urgentDays) : '';
            }

            if (warningInput) {
                warningInput.value = Number.isFinite(warningDays) ? Math.round(warningDays) : '';
            }

            modal.style.display = 'block';
            modal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');

            setTimeout(function() {
                if (urgentInput) {
                    urgentInput.focus();
                }
            }, 60);
        }

        function closePredictionSettings() {
            const modal = document.getElementById('predictionSettingsModal');
            if (!modal) {
                return;
            }

            modal.style.display = 'none';
            modal.setAttribute('aria-hidden', 'true');
            document.body.classList.remove('modal-open');
        }

        function savePredictionSettings() {
            const previousSettings = getPredictionSettings();
            const urgentInput = document.getElementById('urgentDaysInput');
            const warningInput = document.getElementById('warningDaysInput');

            const parsePositiveInteger = function(inputElement) {
                if (!inputElement) {
                    return null;
                }

                const raw = inputElement.value.trim();
                if (raw === '') {
                    return null;
                }

                const numeric = Number(raw);
                return Number.isFinite(numeric) && numeric > 0 ? Math.round(numeric) : null;
            };

            const urgentOverride = parsePositiveInteger(urgentInput);
            let warningOverride = parsePositiveInteger(warningInput);

            if (urgentOverride !== null && warningOverride !== null && warningOverride < urgentOverride) {
                warningOverride = urgentOverride;
            }

            setLocalConfigValue('predictions.urgentDays', urgentOverride);
            setLocalConfigValue('predictions.warningDays', warningOverride);

            const updatedSettings = getPredictionSettings();

            closePredictionSettings();
            applyAllFilters();

            const hasChanges = previousSettings.urgentDays !== updatedSettings.urgentDays
                || previousSettings.warningDays !== updatedSettings.warningDays;

            showToast(
                hasChanges ? 'Limiares preditivos atualizados com sucesso!' : 'Nenhuma altera√ß√£o aplicada aos limiares.',
                hasChanges ? 'success' : 'warning'
            );
        }

        function resetPredictionSettings() {
            const previousSettings = getPredictionSettings();

            setLocalConfigValue('predictions.urgentDays', null);
            setLocalConfigValue('predictions.warningDays', null);

            const updatedSettings = getPredictionSettings();

            closePredictionSettings();
            applyAllFilters();

            const hasChanges = previousSettings.urgentDays !== updatedSettings.urgentDays
                || previousSettings.warningDays !== updatedSettings.warningDays;

            showToast(
                hasChanges ? 'Limiares restaurados para os padr√µes configurados.' : 'Os limiares j√° estavam nos valores padr√£o.',
                hasChanges ? 'success' : 'warning'
            );
        }
        function updateSummary() {
            const total = filteredData.length;
            const coverageValues = filteredData
                .map(function(p) {
                    const coverage = getCoverageValue(p);
                    return Number.isFinite(coverage) ? coverage : null;
                })
                .filter(function(value) { return value !== null; })
                .sort(function(a, b) { return a - b; });

            const totalCoverage = coverageValues.reduce(function(sum, value) {
                return sum + value;
            }, 0);

            const avgStock = coverageValues.length > 0 ? totalCoverage / coverageValues.length : 0;
            const families = new Set(filteredData.map(function(p) {
                return p.family;
            })).size;
            const totalStock = filteredData.reduce(function(sum, product) {
                return sum + getProductStock(product);
            }, 0);
            const safeTotalStock = Number.isFinite(totalStock) ? totalStock : 0;

            document.getElementById('totalProducts').textContent = total;
            const averageCoverageDisplay = coverageValues.length > 0 ? formatCoverageDisplay(avgStock) : null;
            const totalCoverageDisplay = coverageValues.length > 0 ? formatCoverageDisplay(totalCoverage) : null;
            document.getElementById('avgStockMonths').textContent = averageCoverageDisplay
                ? (averageCoverageDisplay.unitLabel
                    ? `${averageCoverageDisplay.displayValue} ${averageCoverageDisplay.unitLabel}`.trim()
                    : averageCoverageDisplay.displayValue)
                : '--';
            document.getElementById('totalCoverage').textContent = totalCoverageDisplay
                ? (totalCoverageDisplay.unitLabel
                    ? `${totalCoverageDisplay.displayValue} ${totalCoverageDisplay.unitLabel}`.trim()
                    : totalCoverageDisplay.displayValue)
                : '--';
            document.getElementById('totalStockValue').textContent = formatWeightDisplay(safeTotalStock);
            document.getElementById('totalFamilies').textContent = families;
        }

        function updateParetoAnalysis() {
            const container = document.getElementById('paretoContent');
            if (!container) {
                return;
            }

            if (!Array.isArray(filteredData) || filteredData.length === 0) {
                container.innerHTML = '<p class="pareto-empty">Nenhum produto para an√°lise.</p>';
                return;
            }

            const sortedData = filteredData.slice().sort(function(a, b) {
                return (b.vendas4M || 0) - (a.vendas4M || 0);
            });
            const totalSales = sortedData.reduce(function(sum, product) {
                const sales = Math.max(product.vendas4M || 0, 0);
                return sales > 0 ? sum + sales : sum;
            }, 0);

            if (totalSales === 0) {
                container.innerHTML = '<p class="pareto-empty">Sem dados de vendas para calcular a an√°lise ABC.</p>';
                return;
            }

            const displayLimit = 10;
            const rows = [];
            const normalizeShare = function(value) {
                if (!Number.isFinite(value)) {
                    return 0;
                }
                if (value < 0) {
                    return 0;
                }
                if (value > 1) {
                    return 1;
                }
                return value;
            };

            sortedData.forEach(function(product, index) {
                const sales = Math.max(product.vendas4M || 0, 0);
                const hasStoredShare = typeof product.individualSalesShare === 'number' && Number.isFinite(product.individualSalesShare);
                const fallbackShare = totalSales === 0 ? 0 : sales / totalSales;
                const individualShare = hasStoredShare
                    ? normalizeShare(product.individualSalesShare)
                    : normalizeShare(fallbackShare);

                if (!hasStoredShare) {
                    product.individualSalesShare = individualShare;
                }

                const rawClass = (typeof product.currentAbcClass === 'string' && product.currentAbcClass)
                    ? product.currentAbcClass.toUpperCase()
                    : '‚Äî';
                const isValidClass = rawClass === 'A' || rawClass === 'B' || rawClass === 'C';
                const classification = isValidClass ? rawClass : '‚Äî';
                const classificationCell = isValidClass
                    ? `<span class="abc-chip abc-${classification.toLowerCase()}">${classification}</span>`
                    : '‚Äî';

                if (index < displayLimit) {
                    rows.push(`
                        <tr>
                            <td>${index + 1}</td>
                            <td>${product.code}</td>
                            <td>${product.item}</td>
                            <td>${(product.vendas4M || 0).toLocaleString()}</td>
                            <td>${(individualShare * 100).toFixed(1)}%</td>
                            <td>${classificationCell}</td>
                        </tr>
                    `);
                }
            });

            const tableHtml = `
                <table class="pareto-table">
                    <thead>
                        <tr>
                            <th><span class="header-label">#<span class="info-icon has-tooltip" tabindex="0" aria-label="Posi√ß√£o no ranking" data-tooltip="Lugar do produto na lista, indo do que mais vende para o que menos vende." data-tooltip-position="top">?</span></span></th>
                            <th><span class="header-label">C√≥digo<span class="info-icon has-tooltip" tabindex="0" aria-label="C√≥digo do produto" data-tooltip="N√∫mero usado no sistema para identificar o produto." data-tooltip-position="top">?</span></span></th>
                            <th><span class="header-label">Item<span class="info-icon has-tooltip" tabindex="0" aria-label="Descri√ß√£o do item" data-tooltip="Nome do produto como aparece no cadastro." data-tooltip-position="top">?</span></span></th>
                            <th><span class="header-label">Vendas 3M<span class="info-icon has-tooltip" tabindex="0" aria-label="Vendas nos √∫ltimos 4 meses" data-tooltip="Total vendido nos √∫ltimos 4 meses considerado nesta an√°lise." data-tooltip-position="top">?</span></span></th>
                            <th><span class="header-label">% Individual<span class="info-icon has-tooltip" tabindex="0" aria-label="Percentual individual" data-tooltip="Mostra quanto o produto representa sozinho do total vendido pelos itens com sa√≠da. Com base nele definimos as classes: 5% ou mais ‚Üí A; entre 1% e 5% ‚Üí B; abaixo de 1% ‚Üí C." data-tooltip-position="top">?</span></span></th>
                            <th><span class="header-label">Classe<span class="info-icon has-tooltip" tabindex="0" aria-label="Classe ABC" data-tooltip="Definida diretamente pelo % Individual do item: 5% ou mais das vendas ficam na Classe A, entre 1% e 5% na Classe B e o restante na Classe C." data-tooltip-position="top">?</span></span></th>
                        </tr>
                    </thead>
                    <tbody>
                        ${rows.join('')}
                    </tbody>
                </table>
            `;

            const footer = sortedData.length > displayLimit
                ? `<p class="pareto-empty">Exibindo top ${displayLimit} de ${sortedData.length} produtos.</p>`
                : '';

            container.innerHTML = tableHtml + footer;
            initializeTooltips(container);
        }

        function updateTable() {
            const tableBody = document.getElementById('productsTableBody');
            tableBody.innerHTML = '';

            filteredData.forEach(function(product) {
                const row = document.createElement('tr');
                const stock14Value = Number(product.stock14 || 0);
                const stock9013Value = Number(product.stock9013 || 0);
                const stock9015Value = Number(product.stock9015 || 0);
                const totalStock = stock14Value + stock9013Value + stock9015Value;
                const coverageValue = getCoverageValue(product);
                const coverageMeta = getCoverageSourceMetadata(product);
                const normalizedCoverage = Number.isFinite(product.stockMonths)
                    ? product.stockMonths
                    : (Number.isFinite(coverageValue) ? coverageValue : 0);
                const statusClass = getStatusClass(normalizedCoverage);
                const predictionInfo = getPrediction(product);
                const predictionCellContent = predictionInfo
                    ? `<span class="tooltip-underline has-tooltip prediction-tooltip" tabindex="0" aria-label="Detalhes da previs√£o" data-tooltip="${escapeTooltip(predictionInfo.detail || predictionInfo.fullText || '')}">${escapeTooltip(predictionInfo.label || '--')}</span>`
                    : '--';

                const vendas4MDisplay = (!product.vendas4M || product.vendas4M === 0) ? 'S/ VENDA' : Number(product.vendas4M).toLocaleString('pt-BR');
                const vendas4MClass = (!product.vendas4M || product.vendas4M === 0) ? 'status-warning' : '';
                const media3MDisplay = Number.isFinite(product.media3M)
                    ? Math.round(product.media3M).toLocaleString('pt-BR')
                    : '0';
                const hasCoverageData = coverageMeta.key !== 'none' && Number.isFinite(coverageValue);
                const coverageDisplay = hasCoverageData ? formatCoverageDisplay(coverageValue) : null;
                const coverageValueDisplay = coverageDisplay
                    ? (coverageDisplay.unitLabel
                        ? `${coverageDisplay.displayValue} ${coverageDisplay.unitLabel}`.trim()
                        : coverageDisplay.displayValue)
                    : '--';
                const coverageSourceClass = coverageMeta.className;
                const coverageSourceLabel = coverageMeta.label;
                const coverageSourceDetail = coverageMeta.detail || '';
                const coverageSourceTitle = coverageSourceDetail
                    ? ` title="${escapeTooltip(coverageSourceDetail)}"`
                    : '';
                const codeValue = (product.code || '').toString();
                const hasCode = codeValue.trim() !== '';
                const safeCodeAttr = escapeTooltip(codeValue);
                const codeDisplay = hasCode ? escapeTooltip(codeValue) : '‚Äî';
                const codeCellContent = hasCode
                    ? `<span class="code-value">${codeDisplay}</span>`
                    : '‚Äî';
                const safeSupplier = escapeTooltip(product.supplier || '‚Äî');
                const safeFamily = escapeTooltip(product.family || '‚Äî');
                const itemText = escapeTooltip(product.item || '‚Äî');
                const productChipHtml = hasCode
                    ? `<button type="button" class="product-chip" data-code="${safeCodeAttr}" onclick="openProductHistoryFromElement(this)">${itemText}</button>`
                    : `<span class="product-chip product-chip-static">${itemText}</span>`;
                const rawCoverageTagLabel = (coverageSourceLabel || '').trim();
                const normalizedCoverageTagLabel = rawCoverageTagLabel.toLowerCase();
                const coverageTagText = (normalizedCoverageTagLabel === 'planilha' || normalizedCoverageTagLabel === 'dados importados')
                    ? ''
                    : rawCoverageTagLabel;
                const coverageTagHtml = coverageTagText
                    ? `<span class="coverage-tag ${coverageSourceClass}"${coverageSourceTitle}>${coverageTagText}</span>`
                    : '';
                const itemCellContent = `
                    <div class="item-name">${productChipHtml}</div>
                    <div class="item-coverage">
                        Cobertura: <strong>${coverageValueDisplay}</strong>
                        ${coverageTagHtml}
                    </div>
                `.trim();

                const fallbackAbcClass = abcClassificationMap.get(product.code);
                const rawAbcClass = (typeof product.currentAbcClass === 'string' && product.currentAbcClass)
                    ? product.currentAbcClass
                    : fallbackAbcClass;
                const normalizedAbcClass = (typeof rawAbcClass === 'string' && rawAbcClass)
                    ? rawAbcClass.toUpperCase()
                    : '‚Äî';
                const isValidAbcClass = normalizedAbcClass === 'A' || normalizedAbcClass === 'B' || normalizedAbcClass === 'C';
                const abcCellContent = isValidAbcClass
                    ? `<span class="abc-chip abc-${normalizedAbcClass.toLowerCase()}">${normalizedAbcClass}</span>`
                    : '‚Äî';

                row.innerHTML = `
                    <td>${codeCellContent}</td>
                    <td>${safeSupplier}</td>
                    <td>${safeFamily}</td>
                    <td>${itemCellContent}</td>
                    <td>${stock14Value.toLocaleString('pt-BR')}</td>
                    <td>${stock9013Value.toLocaleString('pt-BR')}</td>
                    <td>${stock9015Value.toLocaleString('pt-BR')}</td>
                    <td><strong>${totalStock.toLocaleString('pt-BR')}</strong></td>
                    <td class="${vendas4MClass}">${vendas4MDisplay}</td>
                    <td>${media3MDisplay}</td>
                    <td class="status-cell prediction-cell ${statusClass}">${predictionCellContent}</td>
                    <td class="status-cell ${statusClass}">${getStatusText(normalizedCoverage)}</td>
                    <td>${abcCellContent}</td>

                `;

                if (normalizedAbcClass === 'A') {
                    row.classList.add('abc-row-a');
                } else if (normalizedAbcClass === 'B') {
                    row.classList.add('abc-row-b');
                } else if (normalizedAbcClass === 'C') {
                    row.classList.add('abc-row-c');
                }

                row.dataset.abcClass = normalizedAbcClass;

                tableBody.appendChild(row);
            });

            document.getElementById('tableCount').textContent = `${filteredData.length} produtos exibidos`;
            
            if (searchTerm) {
                highlightSearchResults();
            }

            initializeTooltips(tableBody);
        }

        function openProductHistoryFromElement(element) {
            if (!element) {
                return;
            }

            const code = element.getAttribute('data-code');
            if (code) {
                openProductHistory(code);
            }
        }

        function buildProductHistoryDescription(product) {
            return '';
        }

        function openProductHistory(code) {
            if (!code) {
                showMessage('‚ùå C√≥digo inv√°lido para exibir detalhes.', 'error');
                return;
            }

            const normalizedCode = code.toString().trim().toLowerCase();
            const product = allProductsData.find(function(item) {
                return (item.code || '').toString().trim().toLowerCase() === normalizedCode;
            });

            if (!product) {
                showMessage('‚ùå Produto n√£o encontrado para exibir hist√≥rico.', 'error');
                return;
            }

            const modal = document.getElementById('historyModal');
            const contentContainer = document.getElementById('historyModalContent');
            const modalTitle = document.getElementById('historyModalTitle');

            if (!modal || !contentContainer || !modalTitle) {
                showMessage('‚ùå N√£o foi poss√≠vel exibir o hist√≥rico neste momento.', 'error');
                return;
            }

            const aggregatedMonthly = (Array.isArray(product.monthlyValues) && product.monthlyValues.length > 0)
                ? sortMonthlyValues(cloneMonthlyValues(product.monthlyValues))
                : buildFallbackMonthlyValues(product);

            const historyEntries = Array.isArray(product.importHistory)
                ? product.importHistory.map(normalizeHistoryEntry)
                : [];

            const monthlyRows = aggregatedMonthly.length > 0
                ? aggregatedMonthly.map(function(entry) {
                    return `<tr><td>${escapeTooltip(entry.label || 'M√™s')}</td><td>${formatHistoryDisplayValue(entry)}</td></tr>`;
                }).join('')
                : '<tr><td colspan="2">Sem dados mensais importados.</td></tr>';

            const formatMetric = function(value, decimals) {
                const numeric = Number(value);
                if (!Number.isFinite(numeric)) {
                    return '--';
                }
                return numeric.toLocaleString('pt-BR', {
                    minimumFractionDigits: decimals || 0,
                    maximumFractionDigits: decimals || 0
                });
            };

            const coverageMeta = getCoverageSourceMetadata(product);
            const currentCoverageValue = getCoverageValue(product);
            const hasCoverageInfo = coverageMeta.key !== 'none' && Number.isFinite(currentCoverageValue);
            const coverageDisplay = hasCoverageInfo
                ? formatCoverageDisplay(currentCoverageValue)
                : { displayValue: '--', unitLabel: '', unitType: null };
            const coverageValueDisplay = coverageDisplay.displayValue;
            const coverageStatusClass = hasCoverageInfo ? getStatusClass(currentCoverageValue) : 'status-neutral';
            const coverageStatusText = hasCoverageInfo ? getStatusText(currentCoverageValue) : 'Sem dados suficientes';
            const coverageSourceParts = [coverageMeta.label, coverageMeta.detail].filter(Boolean);
            const coverageSourceDescription = coverageMeta.key === 'none'
                ? coverageMeta.detail
                : ((coverageMeta.key === 'cobertura' || coverageMeta.key === 'stockMonths')
                    ? ''
                    : (coverageSourceParts.length > 0
                        ? `Origem dos dados: ${coverageSourceParts.join(' ¬∑ ')}`
                        : ''));
            const coverageUnitHtml = hasCoverageInfo && coverageDisplay.unitLabel
                ? `<span class="history-coverage-unit">${coverageDisplay.unitLabel}</span>`
                : '';
            const coverageSourceNote = coverageSourceDescription
                ? `<p class="history-coverage-meta">${escapeTooltip(coverageSourceDescription)}</p>`
                : '';
            const coverageSectionHtml = `
                <section class="history-overview history-coverage">
                    <div class="history-coverage-info">
                        <div class="history-coverage-main">
                            <div class="history-coverage-heading">
                                <span class="history-coverage-title">Cobertura atual</span>
                                <span class="history-coverage-status ${coverageStatusClass}">${coverageStatusText}</span>
                            </div>
                            <div class="history-coverage-value-group">
                                <span class="history-coverage-value">${coverageValueDisplay}</span>
                                ${coverageUnitHtml}
                            </div>
                        </div>
                        ${coverageSourceNote}
                    </div>
                </section>
            `;

            const historySections = historyEntries.length > 0
                ? historyEntries.map(function(entry, index) {
                    const sectionTitle = entry.sheetName ? escapeTooltip(entry.sheetName) : `Registro ${index + 1}`;
                    const monthsRows = entry.months.length > 0
                        ? entry.months.map(function(monthEntry) {
                            return `<tr><td>${escapeTooltip(monthEntry.label || 'M√™s')}</td><td>${formatHistoryDisplayValue(monthEntry)}</td></tr>`;
                        }).join('')
                        : '<tr><td colspan="2">Sem valores informados.</td></tr>';
                    const totals = entry.totals || {};
                    const totalsMetricsList = [
                        { label: 'Estoque 1-4', value: totals.stock14 },
                        { label: 'Estoque 90-13', value: totals.stock9013 },
                        { label: 'Estoque 90-15', value: totals.stock9015 },
                        { label: 'Estoque Total', value: totals.totalStock },
                        { label: 'Vendas 3M', value: totals.vendas4M },
                        { label: 'M√©dia 3M', value: totals.media3M }
                    ];
                    const totalsMetrics = totalsMetricsList.map(function(metric) {
                        return `<li><span class="history-metric-label">${metric.label}</span><span class="history-metric-value">${formatMetric(metric.value, metric.decimals)}</span></li>`;
                    }).join('');
                    const coverageMetricDisplay = Number.isFinite(totals.cobertura)
                        ? formatCoverageDisplay(totals.cobertura)
                        : null;
                    const coverageMetricHtml = `<li class="history-metric-coverage"><span class="history-metric-label">Estoque em meses</span><span class="history-metric-value">${coverageMetricDisplay && coverageMetricDisplay.unitLabel ? `${coverageMetricDisplay.displayValue} ${coverageMetricDisplay.unitLabel}` : '--'}</span></li>`;
                    const entryCoverageMeta = getCoverageSourceMetadata({
                        coverageSource: entry.coverageSource,
                        stockMonths: totals.cobertura,
                        cobertura: totals.cobertura
                    });
                    const entryCoverageParts = [entryCoverageMeta.label, entryCoverageMeta.detail].filter(Boolean);
                    const entryCoverageDescription = entryCoverageMeta.key === 'none'
                        ? 'Estoque em meses n√£o informado para este per√≠odo.'
                        : ((entryCoverageMeta.key === 'cobertura' || entryCoverageMeta.key === 'stockMonths')
                            ? ''
                            : `Origem dos dados: ${entryCoverageParts.join(' ¬∑ ')}`);
                    const entryCoverageNote = entryCoverageDescription
                        ? `<p class="history-coverage-meta">${escapeTooltip(entryCoverageDescription)}</p>`
                        : '';

                    return `
                        <article class="history-entry">
                            <h4>${sectionTitle}</h4>
                            <div class="history-grid">
                                <div class="history-summary">
                                    <h5>Resumo do per√≠odo</h5>
                                    <ul class="history-metric-list">${totalsMetrics}${coverageMetricHtml}</ul>
                                    ${entryCoverageNote}
                                </div>
                                <div class="history-months">
                                    <h5>Hist√≥rico de importa√ß√µes</h5>
                                    <table class="history-month-table">
                                        <thead><tr><th>M√™s</th><th>Volume</th></tr></thead>
                                        <tbody>${monthsRows}</tbody>
                                    </table>
                                </div>
                            </div>
                        </article>
                    `;
                }).join('')
                : '<p class="empty-history">Sem hist√≥rico de importa√ß√µes salvo para este item.</p>';

            const codeDisplay = escapeTooltip(product.code || '‚Äî');
            const itemDisplay = escapeTooltip(product.item || '‚Äî');
            const supplierDisplay = escapeTooltip(product.supplier || '‚Äî');
            const familyDisplay = escapeTooltip(product.family || '‚Äî');
            const familyAccent = getFamilyAccent(product.family);
            const productDescription = buildProductHistoryDescription(product);
            const descriptionHtml = productDescription
                ? `<p class="history-description">${escapeTooltip(productDescription)}</p>`
                : '';
            const historyStyleAttributes = familyAccent
                ? ` style="--history-header-surface: ${familyAccent.surface}; --history-header-text: ${familyAccent.text}; --history-header-subtext: ${familyAccent.subText}; --history-family-chip-bg: ${familyAccent.chipBackground}; --history-family-chip-text: ${familyAccent.chipText};"`
                : '';

            const historyHtml = `
                <div class="history-modal-content"${historyStyleAttributes}>
                    <header class="history-header">
                        <div class="history-title">
                            <span class="history-code">${codeDisplay}</span>
                            <h1>${itemDisplay}</h1>
                            <p class="history-subtitle">Hist√≥rico e evolu√ß√£o dos dados importados para o produto.</p>
                            ${descriptionHtml}
                        </div>
                        <div class="history-meta">
                            <span class="history-chip">Fornecedor: ${supplierDisplay}</span>
                            <span class="history-chip family-chip">Fam√≠lia: ${familyDisplay}</span>
                        </div>
                    </header>
                    ${coverageSectionHtml}
                    <section class="history-overview">
                        <h2 class="history-section-title">Pr√≥ximas importa√ß√µes</h2>
                        <table class="history-month-table">
                            <thead><tr><th>M√™s</th><th>Volume</th></tr></thead>
                            <tbody>${monthlyRows}</tbody>
                        </table>
                    </section>
                    <section class="history-overview">
                        <h2 class="history-section-title">Hist√≥rico de importa√ß√µes</h2>
                        ${historySections}
                    </section>
                </div>
            `;

            modalTitle.textContent = `Hist√≥rico do Produto ¬∑ ${codeDisplay}`;
            contentContainer.innerHTML = historyHtml;
            modal.style.display = 'block';
            modal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');

            const closeButton = modal.querySelector('.close');
            if (closeButton) {
                closeButton.focus();
            }
        }

        function closeHistoryModal() {
            const modal = document.getElementById('historyModal');
            if (!modal) {
                return;
            }

            modal.style.display = 'none';
            modal.setAttribute('aria-hidden', 'true');
            document.body.classList.remove('modal-open');

            const contentContainer = document.getElementById('historyModalContent');
            if (contentContainer) {
                contentContainer.innerHTML = '';
            }
        }

        window.addEventListener('click', function(event) {
            const modal = document.getElementById('historyModal');
            if (modal && event.target === modal) {
                closeHistoryModal();
            }
        });

        window.addEventListener('keydown', function(event) {
            if (event.key !== 'Escape') {
                return;
            }

            const historyModal = document.getElementById('historyModal');
            if (historyModal && historyModal.style.display === 'block') {
                closeHistoryModal();
            }

            const predictionModal = document.getElementById('predictionSettingsModal');
            if (predictionModal && predictionModal.style.display === 'block') {
                closePredictionSettings();
            }
        });

        function normalizeStockValue(value) {
            const numeric = Number(value);
            return Number.isFinite(numeric) ? numeric : 0;
        }

        function getProductStock(product) {
            const stock14 = normalizeStockValue(product.stock14);
            const stock9013 = normalizeStockValue(product.stock9013);
            const stock9015 = normalizeStockValue(product.stock9015);

            switch(currentEstablishment) {
                case '1-4': return stock14;
                case '90-13': return stock9013;
                case '90-15': return stock9015;
                default: return stock14 + stock9013 + stock9015;
            }
        }

        function getPrediction(product) {
            const coverage = getCoverageInfo(product);
            const { urgentDays, warningDays } = getPredictionSettings();

            if (coverage.outOfStock) {
                return {
                    label: 'S/ Estoque',
                    detail: 'Ruptura imediata ‚Äî produto sem unidades dispon√≠veis no estoque atual.',
                    fullText: 'Sem estoque ‚Äî ruptura imediata',
                    daysToDepletion: 0,
                    estimatedDate: new Date().toISOString(),
                    status: 'urgent'
                };
            }

            if (!coverage.hasDemand || coverage.daysToDepletion === null) {
                return {
                    label: 'Sem demanda recente',
                    detail: 'Sem consumo registrado nos √∫ltimos meses, por isso n√£o √© poss√≠vel estimar a data de ruptura.',
                    fullText: 'Sem demanda recente ‚Äî cobertura indefinida',
                    daysToDepletion: null,
                    estimatedDate: null,
                    status: 'unknown'
                };
            }

            const hasStockMonths = Number.isFinite(product.stockMonths);
            const monthsCoverage = hasStockMonths ? product.stockMonths : (coverage.daysToDepletion / 30);
            const formattedMonths = monthsCoverage !== null ? formatStatValue(monthsCoverage) : '--';
            const daysToDepletion = Math.max(1, Math.round(hasStockMonths ? product.stockMonths * 30 : coverage.daysToDepletion));
            const estimatedDate = new Date(Date.now() + daysToDepletion * 86400000);
            const formattedDate = estimatedDate.toLocaleDateString('pt-BR');
            const monthsText = monthsCoverage !== null ? `${formattedMonths} meses` : 'cobertura indefinida';
            const baseDetail = `Ruptura estimada para ${formattedDate} (cobertura aproximada de ${monthsText}).`;

            if (daysToDepletion <= urgentDays) {
                const label = `Em ${daysToDepletion} dias`;
                const fullText = `Ruptura estimada em ${formattedDate} (aproximadamente ${daysToDepletion} dias).`;
                return {
                    label,
                    detail: `${baseDetail} Recomendado acionar reposi√ß√£o imediata.`,
                    fullText,
                    daysToDepletion,
                    estimatedDate: estimatedDate.toISOString(),
                    status: 'urgent'
                };
            }

            if (daysToDepletion <= warningDays) {
                const label = `Em ${daysToDepletion} dias`;
                const fullText = `Ruptura estimada em ${formattedDate} (aproximadamente ${daysToDepletion} dias).`;
                return {
                    label,
                    detail: `${baseDetail} Planeje reposi√ß√£o para evitar ruptura no curto prazo.`,
                    fullText,
                    daysToDepletion,
                    estimatedDate: estimatedDate.toISOString(),
                    status: 'warning'
                };
            }

            const stableLabel = `${formattedMonths} meses`;
            const fullText = `Ruptura estimada em ${formattedDate} (cobertura aproximada de ${monthsText}).`;
            return {
                label: stableLabel,
                detail: `${baseDetail} Estoque confort√°vel considerando o ritmo de consumo atual.`,
                fullText,
                daysToDepletion,
                estimatedDate: estimatedDate.toISOString(),
                status: 'stable'
            };
        }

        function getStatusClass(months) {
            if (months < 2) return 'status-critical';
            if (months < 6) return 'status-warning';
            return 'status-good';
        }

        function getStatusText(months) {
            if (months < 2) return 'Cr√≠tico';
            if (months < 6) return 'Aten√ß√£o';
            return 'Bom';
        }

        // === FUN√á√ïES DE GAUGES ===
        function updateGauges() {
            const families = [...new Set(filteredData.map(function(p) {
                return p.family;
            }))].sort();
            const container = document.getElementById('gaugesContainer');
            container.innerHTML = '';

            families.forEach(function(family, index) {
                const familyProducts = getFamilyFilteredProducts(family);
                if (familyProducts.length === 0) return;
                
                const avgStock = calculateAverageStock(familyProducts);
                const criticalCount = familyProducts.filter(function(p) {
                    const hasStock = currentEstablishment ? 
                        getProductStock(p) > 0 : 
                        (p.stock14 + p.stock9013 + p.stock9015) > 0;
                    return hasStock && p.stockMonths < 2;
                }).length;

                const card = document.createElement('div');
                card.className = 'gauge-card';
                
                if (selectedFamily === family) {
                    card.classList.add('selected');
                }
                
                const shouldHighlight = searchTerm && family.toLowerCase().includes(searchTerm);
                if (shouldHighlight) {
                    card.classList.add('highlighted');
                }

                card.onclick = function() {
                    filterByGauge(family);
                };
                card.style.cursor = 'pointer';
                card.title = `Clique para filtrar produtos da fam√≠lia ${family}`;

                card.innerHTML = `
                    <div class="gauge-title">${family}</div>
                    <div class="gauge">
                        <canvas id="gauge${index}" width="240" height="140"></canvas>
                        <div class="gauge-value">${avgStock.toFixed(1)}</div>
                        <div class="gauge-label">meses</div>
                    </div>
                    <div style="text-align: center; margin-top: 10px; font-size: 12px; color: #666;">
                        ${familyProducts.length} produtos | ${criticalCount} cr√≠ticos
                    </div>
                `;
                container.appendChild(card);

                setTimeout(function() {
                    card.classList.add('animating');
                }, index * 100);

                drawGauge(`gauge${index}`, avgStock, family, index * 200);
            });
        }

        function getFamilyFilteredProducts(family) {
            return filteredData.filter(function(product) {
                return product.family === family;
            });
        }

        function calculateAverageStock(products) {
            if (products.length === 0) return 0;
            return products.reduce(function(sum, p) {
                return sum + p.stockMonths;
            }, 0) / products.length;
        }

        function drawGauge(canvasId, value, title, delay) {
            delay = delay || 0;
            setTimeout(function() {
                const canvas = document.getElementById(canvasId);
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const centerX = canvas.width / 2;
                const centerY = canvas.height - 25;
                const radius = 90;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, Math.PI, 0);
                ctx.lineWidth = 20;
                ctx.strokeStyle = '#e0e0e0';
                ctx.stroke();

                let color;
                if (value < 3) {
                    color = '#f44336';
                } else if (value < 6) {
                    color = '#ff9800';
                } else {
                    color = '#4caf50';
                }

                const maxValue = 12;
                const targetAngle = Math.min(value / maxValue, 1) * Math.PI;
                let currentAngle = 0;
                const animationDuration = 1000;
                const startTime = Date.now();

                function animate() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / animationDuration, 1);
                    currentAngle = targetAngle * progress;

                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, Math.PI, 0);
                    ctx.lineWidth = 20;
                    ctx.strokeStyle = '#e0e0e0';
                    ctx.stroke();

                    if (currentAngle > 0) {
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius, Math.PI, Math.PI + currentAngle);
                        ctx.lineWidth = 20;
                        ctx.strokeStyle = color;
                        ctx.stroke();
                    }

                    drawGaugeMarks(ctx, centerX, centerY, radius);

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                }

                animate();
            }, delay);
        }

        function drawGaugeMarks(ctx, centerX, centerY, radius) {
            for (let i = 0; i <= 12; i += 3) {
                const markAngle = Math.PI + (i / 12) * Math.PI;
                const x1 = centerX + Math.cos(markAngle) * (radius - 30);
                const y1 = centerY + Math.sin(markAngle) * (radius - 30);
                const x2 = centerX + Math.cos(markAngle) * (radius - 10);
                const y2 = centerY + Math.sin(markAngle) * (radius - 10);

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.lineWidth = 3;
                ctx.strokeStyle = '#333';
                ctx.stroke();

                if (i % 6 === 0) {
                    const textX = centerX + Math.cos(markAngle) * (radius - 45);
                    const textY = centerY + Math.sin(markAngle) * (radius - 45);
                    ctx.fillStyle = '#333';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(i.toString(), textX, textY + 5);
                }
            }
        }

        // === FUN√á√ïES DE EXPORTA√á√ÉO ===
        function showExportModal() {
            const modal = document.getElementById('exportModal');
            const currentDate = new Date().toISOString().split('T')[0];
            document.getElementById('fileName').value = `estoque_preditivo_${currentDate}`;
            modal.style.display = 'block';
        }

        function closeExportModal() {
            document.getElementById('exportModal').style.display = 'none';
        }

        function confirmExport() {
            const fileName = document.getElementById('fileName').value || 'estoque_dados';
            const fileFormat = document.getElementById('fileFormat').value;
            
            const exportData = filteredData.map(function(p) {
                const predictionInfo = getPrediction(p);
                const coverageValueExport = getCoverageValue(p);
                    return {
                        'C√ìDIGO': p.code,
                        'FORNECEDOR': p.supplier,
                        'FAM√çLIA': p.family,
                        'ITEM': p.item,
                        'ESTOQUE 1-4': p.stock14,
                        'ESTOQUE 90-13': p.stock9013,
                        'ESTOQUE 90-15': p.stock9015,
                        'TOTAL ESTOQUE': p.stock14 + p.stock9013 + p.stock9015,
                        'VENDAS 3M': (!p.vendas4M || p.vendas4M === 0) ? 'S/ VENDA' : p.vendas4M,
                        'M√âDIA 3M': p.media3M,
                        'NOVEMBRO': p.novembro,
                        'DEZEMBRO': p.dezembro,
                        'COBERTURA (PLANILHA)': Number.isFinite(coverageValueExport) ? coverageValueExport : '',
                        'ESTOQUE EM MESES': p.stockMonths,
                        'PREVIS√ÉO': predictionInfo ? (predictionInfo.fullText || predictionInfo.label) : '--',
                        'STATUS': getStatusText(p.stockMonths)
                    };
                });

            if (fileFormat === 'csv') {
                const csv = convertToCSV(exportData);
                downloadFile(csv, `${fileName}.csv`, 'text/csv');
            } else {
                const ws = XLSX.utils.json_to_sheet(exportData);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, 'Estoque');
                XLSX.writeFile(wb, `${fileName}.xlsx`);
            }
            
            closeExportModal();
        }

        function convertToCSV(data) {
            const headers = Object.keys(data[0]);
            const csvContent = [
                headers.join(',')
            ].concat(data.map(function(row) {
                return headers.map(function(header) {
                    return `"${row[header]}"`;
                }).join(',');
            })).join('\n');
            return csvContent;
        }

        function downloadFile(content, fileName, contentType) {
            const blob = new Blob([content], { type: contentType });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }

        function updateData() {
            clearAllFilters();
            loadData();
            showMessage('‚úÖ Dashboard atualizado!', 'success');
        }

        // Fechar modal ao clicar fora dele
        window.onclick = function(event) {
            const exportModal = document.getElementById('exportModal');
            if (exportModal && event.target === exportModal) {
                closeExportModal();
            }

            const predictionModal = document.getElementById('predictionSettingsModal');
            if (predictionModal && event.target === predictionModal) {
                closePredictionSettings();
            }
        }

        // Carregar arquivo de dados externo
        function loadExternalDataScript() {
            debugLog('Carregando data.js externo...');
            
            const script = document.createElement('script');
            script.src = 'data.js';
            script.onerror = function() {
                debugLog('Arquivo data.js n√£o encontrado, usando localStorage ou dados vazios');
                loadData();
            };
            script.onload = function() {
                debugLog('Arquivo data.js carregado com sucesso');
                setTimeout(function() {
                    loadData();
                }, 100);
            };
            document.head.appendChild(script);
        }

        // === INICIALIZA√á√ÉO ===
        document.addEventListener('DOMContentLoaded', function() {
            debugLog('=== INICIALIZA√á√ÉO DO DASHBOARD v1.3 ===');
            debugLog('DOM carregado, iniciando processo...');

            try {
                initializeTooltips();
                // Primeiro detectar capacidades do navegador
                detectBrowserCapabilities();
                applyPredictionLabels();

                // Depois carregar dados
                loadExternalDataScript();
                
                // Configura√ß√µes iniciais ap√≥s carregar
                setTimeout(function() {
                    updateUI();
                    
                    // Se n√£o h√° dados, abrir automaticamente a se√ß√£o de importa√ß√£o
                    if (allProductsData.length === 0) {
                        debugLog('Nenhum dado encontrado, se√ß√£o de importa√ß√£o j√° est√° aberta');
                    }
                }, 1500);
                
            } catch (error) {
                debugLog(`Erro na inicializa√ß√£o: ${error.message}`, 'error');
                // Fallback: tentar carregar dados mesmo com erro
                try {
                    loadData();
                } catch (e) {
                    debugLog(`Erro no fallback: ${e.message}`, 'error');
                    showMessage('‚ùå Erro ao inicializar dashboard. Use o diagn√≥stico para mais detalhes.', 'error');
                }
            }
        });

        // Adicionar event listeners para inputs
        document.addEventListener('DOMContentLoaded', function() {
            const searchInput = document.getElementById('globalSearch');
            const searchResultsContainer = document.getElementById('searchResults');
            if (searchInput) {
                // Throttle para melhor performance
                let searchTimeout;
                searchInput.addEventListener('input', function() {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(performGlobalSearch, 300);
                });

                searchInput.addEventListener('focus', function() {
                    if (searchResultsHidden && searchResultsCacheHtml) {
                        restoreSearchResultsFromCache();
                    }
                });

                searchInput.addEventListener('click', function() {
                    if (searchResultsHidden && searchResultsCacheHtml) {
                        restoreSearchResultsFromCache();
                    }
                });
            }

            if (searchResultsContainer) {
                searchResultsContainer.addEventListener('click', handleSearchSuggestionClick);
            }
        });

        document.addEventListener('click', function(event) {
            const searchSection = document.querySelector('.search-section');
            if (!searchSection) {
                return;
            }

            if (event.target.closest('.search-section')) {
                return;
            }

            if (searchResultsCacheHtml || (document.getElementById('searchResults') && document.getElementById('searchResults').innerHTML.trim() !== '')) {
                hideSearchResultsTemporarily();
            }
        });

        // Detectar mudan√ßas no localStorage (para sincroniza√ß√£o entre abas)
        window.addEventListener('storage', function(e) {
            if (e.key === 'stockData') {
                debugLog('Detectada mudan√ßa nos dados do localStorage');
                loadData();
            }
        });

        // Log de informa√ß√µes do sistema ao carregar
        console.log(`
üöÄ DASHBOARD DE ESTOQUE v1.3 - PAULO ROBERTO S. S. (@PAROSOSI)
===================================================
üìÖ Data: ${new Date().toLocaleString('pt-BR')}
üåê Navegador: ${navigator.userAgent}
üîç URL: ${window.location.href}
üîë Protocolo: ${window.location.protocol}
üíª Tela: ${screen.width}x${screen.height}
üì± Viewport: ${window.innerWidth}x${window.innerHeight}
üîß Debug: Use toggleDebug() para ativar logs detalhados
üìã Mapeamento: Use toggleMappingDebug() para ver mapeamento de colunas
===================================================
        `);
    </script>
</body>
</html>
